module M_sets
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK COMMENT --file M_sets.3m_sets.man
NAME
   M_sets(3f) - [M_sets::INTRO] functions reminiscent of Matlab set
   functions

SYNOPSIS
   Procedure names and syntax:

    use M_sets, only : &
    & union, unique, intersect, setdiff, ismember, setxor
    use M_sets, only : &
    & issorted, isequal, bool

DESCRIPTION

Set operations compare the elements in two sets to find commonalities
or differences. This includes Unions, Intersections, and Membership.

M_set(3f) is a Fortran module comprising a small subset of set theory
functions reminiscent of Matlab functions.

The functions currently support vectors of integer, default character,
and default real and doubleprecision type.

float numbers (both kind=real32 and kind=real64) are allowed but "caveat
emptor", as comparing floats for equality has issues. You may have to
condition the float data by converting it to scaled integers or using
intrinsics such as NEAREST(3f) to produce the desired results.

M_set(3f) primarily uses simple calls to the M_orderpack(3f) module to
provide the functionality. The functions are not otherwise tuned for
performance and make loose use of memory allocation but are sufficient
for most uses, simple to use, and familiar to a large base of users.

## Functions
 + union(A,B,setOrder)     - Join two sets and remove duplicates of values
 + unique(A,setOrder)      - Remove duplicates of values from a set
 + intersect(A,B,setOrder) - Find the values common to both A and B
 + setdiff(A,B,setOrder)   - Find the values in A that are not in B
 + ismember(A,B,setOrder)  - Create a mask of A marking elements also in B
 + setxor(A,B,setOrder)    - Find values of A and B not in both arrays
 + issorted(A)             - Determine if array is already sorted
 + isequal(A,B)             -Determine if two sets are equal with a tolerance
 + bool(expr)              - 1 if logical expression is true, 0 if false.

 The subsequent data may be produced sorted, or left in the order
 encountered.

EXAMPLES

 sample program:

   program demo_M_sets
   use M_sets, only: &
   & unique, intersect, union, setdiff, setxor, bool, &
   & ismember, issorted, isequal
   character(len=*),parameter :: all='(*(g0,1x))'
   character(len=*),parameter :: nl=new_line('A')
   integer, allocatable      :: A(:)
   integer, allocatable      :: B(:)
   integer, allocatable      :: C(:)

      A = [10, -10, 0, 1, 2, 3, 3, 2, 1, -10]
      !
      print all                                                   ,nl, &
      'UNIQUE','Find the unique elements of vector A.'            ,nl, &
      'A=', A                                                     ,nl, &
      'sorted=',unique(A)                                         ,nl, &
      'stable=',unique(A, setOrder='stable')

      A=[5, 7, 1]
      B=[3, 1, 1]
      !
      print all                                                   ,nl, &
      'UNION', 'Find the union of vectors A and B.'               ,nl, &
      'A=', A                                                     ,nl, &
      'B=', B                                                     ,nl, &
      'sorted=',union(A, B, 'sorted')                             ,nl, &
      'stable=',union(A, B, 'stable')

      A=[7, 1, 7, 7, 4]
      B=[7, 0, 4, 4, 0]
      !
      print all                                                   ,nl, &
      'INTERSECT', 'Find the values common to both A and B.'      ,nl, &
      'A=', A                                                     ,nl, &
      'B=', B                                                     ,nl, &
      'sorted=',intersect(A, B)                                   ,nl, &
      'stable=',intersect(A, B, setOrder='stable')

      A=[3, 6, 2, 1, 5, 1, 1]
      B=[2, 4, 6]
      !
      print all                                                   ,nl, &
      'SETDIFF','Find the values in A that are not in B.'         ,nl, &
      'A=', A                                                     ,nl, &
      'B=', B                                                     ,nl, &
      'sorted=',setdiff(A, B, 'sorted')                           ,nl, &
      'stable=',setdiff(A, B, 'stable')

      A=[5,3,4,2]
      B=[2,4,4,4,6,8]
      !
      print all                                                   ,nl, &
      'ISMEMBER','Determine which elements of A are also in B.'   ,nl, &
      'A=', A                                                     ,nl, &
      'B=', B                                                     ,nl, &
      'in A and B=',ismember(A,B)

      A=[5,1,3,3,3]
      B=[4,1,2]
      !
      print all                                                   ,nl, &
      'SETXOR'                                                       , &
      'Find values of A and B not in their intersection.'         ,nl, &
      'A=', A                                                     ,nl, &
      'B=', B                                                     ,nl, &
      'sorted=',setxor(A,B)                                       ,nl, &
      'stable=',setxor(A,B,'stable')

      A=[1,2,3,4,5]
      B=[5,4,3,2,1]
      !
      print all                                                   ,nl, &
      'ISSSORTED'                                                    , &
      'confirm whether array is sorted in ascending order or not' ,nl, &
      'A=', A                                                     ,nl, &
      'B=', B                                                     ,nl, &
      'is A sorted?',issorted(A)                                  ,nl, &
      'is B sorted?',issorted(B)

      A=[1,2,3,4,5]
      B=[1,2,3,4,5]
      !
      print all                                                   ,nl, &
      'ISEQUAL'                                                     , &
      'confirm whether sets have same elements in same order    ' ,nl, &
      'A=', A                                                     ,nl, &
      'B=', B                                                     ,nl, &
      'is A equal to B?',isequal(A,B)                             ,nl, &
      'is B equal to -B?',isequal(A,-B)

      A=[1,2,3,4,5]
      B=[5,2,3,4,1]
      !
      print all                                                   ,nl, &
      'BOOL'                                                         , &
      'if logical expression is true, 0 if false.'                ,nl, &
      'A=', A                                                     ,nl, &
      'B=', B                                                     ,nl, &
      'is A(i) = B(i) ?',bool(A==B)                               ,nl, &
      'how many elements are the same?',sum(bool(A==B))

   end program demo_M_sets

Results:

 >
 >  UNIQUE Find the unique elements of vector A.
 >  A= 10 -10 0 1 2 3 3 2 1 -10
 >  sorted= -10 0 1 2 3 10
 >  stable= 10 -10 0 1 2 3
 >
 >  UNION Find the union of vectors A and B.
 >  A= 5 7 1
 >  B= 3 1 1
 >  sorted= 1 3 5 7
 >  stable= 5 7 1 3
 >
 >  INTERSECT Find the values common to both A and B.
 >  A= 7 1 7 7 4
 >  B= 7 0 4 4 0
 >  sorted= 4 7
 >  stable= 7 4
 >
 >  SETDIFF Find the values in A that are not in B.
 >  A= 3 6 2 1 5 1 1
 >  B= 2 4 6
 >  sorted= 1 3 5
 >  stable= 3 1 5
 >
 >  ISMEMBER Determine which elements of A are also in B.
 >  A= 5 3 4 2
 >  B= 2 4 4 4 6 8
 >  in A and B= 0 0 1 1
 >
 >  SETXOR Find values of A and B not in their intersection.
 >  A= 5 1 3 3 3
 >  B= 4 1 2
 >  sorted= 2 3 4 5
 >  stable= 5 3 4 2
 >
 >  ISSSORTED confirm whether array is sorted in ascending order or not
 >  A= 1 2 3 4 5
 >  B= 5 4 3 2 1
 >  is A sorted? 1
 >  is B sorted? 0
 >
 >  BOOL if logical expression is true, 0 if false.
 >  A= 1 2 3 4 5
 >  B= 5 2 3 4 1
 >  is A(i) = B(i) ? 0 1 1 1 0
 >  how many elements are the same? 3

AUTHORS
   John S. Urban, 2023-07-20

LICENSE
   CC0-1.0
$ENDBLOCK
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
! a subset of the functionality of set functions in Matlab are provided.
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64
use,intrinsic :: iso_fortran_env, only : real32,real64,real128
use M_orderpack, only: unique_ => unique, occurrences_ => occurrences, sort_ => sort
use M_orderpack, only: rank_unique_ => rank_unique

private

public :: unique    ! C = unique(A,setOrder)        returns the same data as in A, but with no repetitions.
public :: union     ! C = union(A,B,setOrder)       returns the combined data from A and B with no repetitions.
public :: intersect ! C = intersect(A,B,setOrder)   returns the data common to both A and B, with no repetitions.
public :: setdiff   ! C = setdiff(A,B,setOrder)     returns the data in A that is not in B, with no repetitions.
public :: ismember  ! C = ismember(A,B) returns     an array containing 1 (true) where the data in A is found in B. Elsewhere, 0.
public :: setxor    ! C = setxor(A,B,setOrder)      returns the data of A and B that are not in their intersection
                    !                               (the symmetric difference), with no repetitions. That is, setxor returns the
                    !                               data that occurs in A or B, but not both. C is in sorted order.
public :: issorted  ! C = issorted(A)               determine if A is in ascending order or not
public :: isequal   ! C = isequal(A,B,tolerance)    determine if set A has same element values in same order as B to 
                    !                               within a tolerance
public :: bool      ! C = bool(logical_expression)  1 if logical expression is true, 0 if false.

$PARCEL MODULARIZE

interface unique;    module procedure unique_${KIND};    end interface unique
interface union;     module procedure union_${KIND};     end interface union
interface intersect; module procedure intersect_${KIND}; end interface intersect
interface setdiff;   module procedure setdiff_${KIND};   end interface setdiff
interface ismember;  module procedure ismember_${KIND};  end interface ismember
interface setxor;    module procedure setxor_${KIND};    end interface setxor
interface issorted;  module procedure issorted_${KIND};  end interface issorted
interface isequal;   module procedure isequal_${KIND};   end interface isequal
$ENDPARCEL MODULARIZE

$set KIND c
$POST MODULARIZE
$set KIND int8
$POST MODULARIZE
$set KIND int16
$POST MODULARIZE
$set KIND int32
$POST MODULARIZE
$set KIND int64
$POST MODULARIZE
$set KIND real32
$POST MODULARIZE
$set KIND real64
$POST MODULARIZE

interface bool
        module procedure :: bool_expr
        module procedure :: bool_int8, bool_int16, bool_int32, bool_int64
        module procedure :: bool_float32, bool_float64
        module procedure :: bool_complex32, bool_complex64
        module procedure :: bool_char
end interface bool

contains

$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK COMMENT --file unique.3m_sets.man
NAME
   unique(3f) - [M_sets] return unique values in array A

SYNOPSIS

   unique(A,setOrder)

DESCRIPTION

unique(3) returns the unique values found in an array. That is, it
eliminates all but one occurrence of each value.

The result is in sorted order by default, but may be returned in the
order found.

OPTIONS

    A         input array to extract unique values from
    setOrder  May be "sort" or "stable". If "stable" the values are
              returned in the order discovered. The default is
              "sorted", which returns the data in ascending order.

RETURNS

    All the values that occur in the input occur in the output
    just once. All duplicates are removed.

EXAMPLES

 sample program:

   program demo_unique
   use M_sets, only: unique
   character(len=*),parameter :: g='(*(g0,1x))'
   integer,allocatable        :: A(:)

      write(*,g) 'UNIQUE','Find the unique elements of vector A.'
       A = [10, -10, 0, 1, 2, 3, 3, 2, 1, -10]
       write(*,g) 'A=', A
       write(*,g) unique(A)
       write(*,g) unique(A, setOrder='stable')

   end program demo_unique

Results:

 > UNIQUE Find the unique elements of vector A.
 > A= 10 -10 0 1 2 3 3 2 1 -10
 > -10 0 1 2 3 10
 > 10 -10 0 1 2 3

AUTHORS
   John S. Urban, 2023-07-20

LICENSE
   CC0-1.0
$ENDBLOCK
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$PARCEL UNIQUE_TEMPLATE
function unique_${KIND}(A, setOrder) result(answer)
! C = unique(A) returns the same data as in A, but with no repetitions. C is in sorted order.
${TYPE}(kind=${KIND}), intent(in)      :: A(:)
character(len=*), intent(in), optional :: setOrder
${TYPE}(kind=${KIND}),allocatable      :: answer(:)
integer,allocatable                    :: indices(:)
character(len=:), allocatable          :: setOrder_
integer                                :: nuni

   if (present(setOrder)) then
      setOrder_ = setOrder
   else
      setOrder_ = 'sorted'
   endif
   answer = A
   select case (lower(setOrder_))
   case ('stable')
      call unique_(answer, nuni)
      answer = answer(:nuni)
   case ('sorted')
      if (allocated(indices)) deallocate (indices)
      allocate (indices(size(A)))
      call rank_unique_(A, indices, nuni)
      answer = A(indices(:nuni))
   case default
      stop '*unique* unknown setOrder '//setOrder_//'allowed are "stable" and "sorted"'
   end select
end function unique_${KIND}
$ENDPARCEL UNIQUE_TEMPLATE
!-----------------------------------------------------------------------------------------------------------------------------------
function unique_c(A, setOrder) result(answer)
! C = unique(A) returns the same data as in A, but with no repetitions. C is in sorted order.
character(len=*), intent(in)           :: A(:)
character(len=*), intent(in), optional :: setOrder
character(len=:), allocatable          :: answer(:)
character(len=:), allocatable          :: setOrder_
integer                                :: nuni
   if (present(setOrder)) then
      setOrder_ = setOrder
   else
      setOrder_ = 'sorted'
   endif
   answer = A
   call unique_(answer, nuni)
   answer = answer(:nuni)
   select case (lower(setOrder_))
   case ('stable')
   case ('sorted')
      call sort_(answer)
   case default
      stop '*unique* unknown setOrder '//setOrder_//' allowed are "stable" and "sorted"'
   end select
end function unique_c
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK COMMENT --file union.3m_sets.man
NAME
   union(3f) - [M_sets] Join two sets and removes duplicates of values

SYNOPSIS

   union(A,B, setOrder)

DESCRIPTION

The two sets are combined and repetitions are removed.

OPTIONS

    A         input array
    B         input array
    setOrder  May be "sort" or "stable". If "stable" the values are
              returned in the order discovered. The default is
              "sorted", which returns the data in ascending order.

EXAMPLES

 sample program:

   program demo_union
   use M_sets, only: union
   character(len=*),parameter :: g='(*(g0,1x))'
   integer,allocatable        :: A(:)
   integer,allocatable        :: B(:)

      write(*,g) 'UNION', 'Find the union of vectors A and B.'
      A=[5, 7, 1]
      B=[3, 1, 1]
      write(*,g) 'A=', A
      write(*,g) 'B=', B
      write(*,g) union(A,B)

      A=[5, 5, 3]
      B=[1, 2, 5]
      write(*,g) 'A=', A
      write(*,g) 'B=', B
      write(*,g) union(A, B, 'sorted')
      write(*,g) union(A, B, 'stable')

   end program demo_union
```
Results:

 > UNION Find the union of vectors A and B.
 > A= 5 7 1
 > B= 3 1 1
 > 1 3 5 7
 > A= 5 5 3
 > B= 1 2 5
 > 1 2 3 5
 > 5 3 1 2

AUTHORS
   John S. Urban, 2023-07-20

LICENSE
   CC0-1.0
$ENDBLOCK
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$PARCEL UNION_TEMPLATE
function union_${KIND}(A, B, setOrder) result(answer)
! C = union(A,B) returns the combined data from A and B with no repetitions. C is in sorted order.
${TYPE}(kind=${KIND}),intent(in)       :: A(:)
${TYPE}(kind=${KIND}),intent(in)       :: B(:)
character(len=*),intent(in), optional  :: setOrder
${TYPE}(kind=${KIND}),allocatable      :: answer(:)
   answer = unique([A, B], setOrder)
end function union_${KIND}
$ENDPARCEL UNION_TEMPLATE
!-----------------------------------------------------------------------------------------------------------------------------------
function union_c(A, B, setOrder) result(answer)
! C = union(A,B) returns the combined data from A and B with no repetitions. C is in sorted order.
character(len=*), intent(in)           :: A(:)
character(len=*), intent(in)           :: B(:)
character(len=*), intent(in), optional :: setOrder
character(len=:), allocatable          :: answer(:)
character(len=:), allocatable          :: kludge(:)
integer                                :: longest
longest=max(len(a),len(b))
   kludge = [character(len=longest) :: A, B]
   answer = unique(kludge, setOrder)
end function union_c
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK COMMENT --file intersect.3m_sets.man
NAME
   intersect(3f) - [M_sets] Find the values common to both sets A and B

SYNOPSIS

   intersect(A,B, setOrder)

DESCRIPTION

The values that occur at least once in each set are returned.

That is, intersect(3f) returns the data common to both A and B, with
no repetitions.

OPTIONS

    A         input array
    B         input array
    setOrder  May be "sort" or "stable". If "stable" the values are
              returned in the order discovered. The default is
              "sorted", which returns the data in ascending order.

EXAMPLES

 sample program:

  program demo_intersect
  use M_sets, only: unique, intersect, union, setdiff, ismember, setxor
  character(len=*),parameter :: g='(*(g0,1x))'
  integer, allocatable       :: A(:)
  integer, allocatable       :: B(:)

     write(*,g) 'INTERSECT', 'Find the values common to both A and B.'
      A=[7, 1, 7, 7, 4]
      B=[7, 0, 4, 4, 0]
      write(*,g) 'A=', A
      write(*,g) 'B=', B
      write(*,g) intersect(A, B)
      write(*,g) intersect(A, B, setOrder='stable')
  end program demo_intersect

Results:

 > INTERSECT Find the values common to both A and B.
 > A= 7 1 7 7 4
 > B= 7 0 4 4 0
 > 4 7
 > 7 4

AUTHORS
   John S. Urban, 2023-07-20

LICENSE
   CC0-1.0
$ENDBLOCK
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$PARCEL INTERSECT_TEMPLATE
function intersect_${KIND}(A, B, setOrder) result(answer)
! C = intersect(A,B) returns the data common to both A and B, with no repetitions. C is in sorted order by default
${TYPE}(kind=${KIND}), intent(in)      :: A(:)
${TYPE}(kind=${KIND}), intent(in)      :: B(:)
character(len=*), intent(in), optional :: setOrder
${TYPE}(kind=${KIND}), allocatable     :: answer(:)
integer, allocatable                   :: iwrk(:)
   answer = [unique(A, setOrder), unique(B, setOrder)]
   if (allocated(iwrk)) deallocate (iwrk)
   allocate (iwrk(size(answer)))
   call occurrences_(answer, iwrk)
   answer = unique(pack(answer, iwrk  >  1), setOrder)
end function intersect_${KIND}
$ENDPARCEL INTERSECT_TEMPLATE
!-----------------------------------------------------------------------------------------------------------------------------------
function intersect_c(A, B, setOrder) result(answer)
! C = intersect(A,B) returns the data common to both A and B, with no repetitions. C is in sorted order by default
character(len=*), intent(in)           :: A(:)
character(len=*), intent(in)           :: B(:)
character(len=*), intent(in), optional :: setOrder
character(len=:), allocatable          :: answer(:)
integer, allocatable                   :: iwrk(:)
character(len=:), allocatable          :: kludge(:)
integer                                :: longest
   longest=max(len(A),len(B))
   answer = [character(len=longest) :: unique(A, setOrder), unique(B, setOrder)]
   if (allocated(iwrk)) deallocate (iwrk)
   allocate (iwrk(size(answer)))
   call occurrences_(answer, iwrk)
   !--------------------------------
   !answer= unique(pack(answer//'',iwrk > 1),setOrder) ! add //' ' to avoid gfortran 13.1.0-8 bug
   kludge=pack(answer//'',iwrk > 1)
   answer = unique(kludge, setOrder)
   !--------------------------------
end function intersect_c
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK COMMENT --file setdiff.3m_sets.man
NAME
   setdiff(3f) - [M_sets] Find the values in A that are not in B

SYNOPSIS

   setdiff(A,B, setOrder)

DESCRIPTION

setdiff(3f) returns the data in A that is not in B, with no repetitions.

OPTIONS

    A         input array
    B         input array
    setOrder  May be "sort" or "stable". If "stable" the values are
              returned in the order discovered. The default is
              "sorted", which returns the data in ascending order.

EXAMPLES

 sample program:

   program demo_setdiff
   use M_sets, only: setdiff
   character(len=*),parameter :: g='(*(g0,1x))'
   integer, allocatable       :: A(:)
   integer, allocatable       :: B(:)

      write(*,g) 'SETDIFF','Find the values in A that are not in B.'
       A=[3, 6, 2, 1, 5, 1, 1]
       B=[2, 4, 6]
       write(*,g) 'A=', A
       write(*,g) 'B=', B
       write(*,g) setdiff(A, B)
       write(*,g) setdiff([4, 1, 3, 2, 5], [2, 1], 'sorted')
       write(*,g) setdiff([4, 1, 3, 2, 5], [2, 1], 'stable')

   end program demo_setdiff

Results:

 > SETDIFF Find the values in A that are not in B.
 > A= 3 6 2 1 5 1 1
 > B= 2 4 6
 > 1 3 5
 > 3 4 5
 > 4 3 5

AUTHORS
   John S. Urban, 2023-07-20

LICENSE
   CC0-1.0
$ENDBLOCK
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$PARCEL SETDIFF_TEMPLATE
function setdiff_${KIND}(A, B, setOrder) result(answer)
! C = setdiff(A,B) returns the data in A that is not in B, with no repetitions. C is in sorted order by default.
${TYPE}(kind=${KIND}), intent(in)      :: a(:)
${TYPE}(kind=${KIND}), intent(in)      :: b(:)
character(len=*), intent(in), optional :: setOrder
${TYPE}(kind=${KIND}), allocatable     :: answer(:)
integer, allocatable                   :: iwrk(:)
   answer = unique(b, setOrder='stable')
   answer = [unique(a, setOrder='stable'), answer, answer] ! potentially a lot of memory
   if (allocated(iwrk)) deallocate (iwrk)
   allocate (iwrk(size(answer)))
   call occurrences_(answer, iwrk)
   answer = unique(pack(answer, iwrk  ==  1), setOrder)

end function setdiff_${KIND}
$ENDPARCEL SETDIFF_TEMPLATE
!-----------------------------------------------------------------------------------------------------------------------------------
function setdiff_c(A, B, setOrder) result(answer)
! C = setdiff(A,B) returns the data in A that is not in B, with no repetitions. C is in sorted order by default.
character(len=*), intent(in)           :: a(:)
character(len=*), intent(in)           :: b(:)
character(len=*), intent(in), optional :: setOrder
character(len=:), allocatable          :: answer(:),kludge(:)
integer         , allocatable          :: iwrk(:)
integer                                :: longest
   answer = unique(b, setOrder='stable')
   longest=max(len(a),len(b))
   answer = [character(len=longest) :: unique(a, setOrder='stable'), answer, answer] ! potentially a lot of memory
   if (allocated(iwrk)) deallocate (iwrk)
   allocate ( iwrk(size(answer)))
   call occurrences_(answer, iwrk)
   !--------------------------------
   !answer = unique(pack(answer, iwrk  ==  1), setOrder)
   kludge = pack(answer//'', iwrk  ==  1)
   answer = unique(kludge, setOrder)
   !--------------------------------

end function setdiff_c
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK COMMENT --file ismember.3m_sets.man
NAME
   ismember(3f) - [M_sets] Create a mask of A marking elements also in B

SYNOPSIS

   ismember(A,B)

DESCRIPTION

Identifies elements of the first set that are members of the second set
as well.

The returned array is a mask of the first array containing a 1
(aka. "true") where the data in A is found in B. Elsewhere, the array
contains 0 (aka. "false").

OPTIONS

    A         input array
    B         input array of values to find in vector A.

RETURNS
    A mask of array A with a 1 at locations where the value in that
    position in A is also a value that occurs in B, and with a 0 at
    locations where that value in A was not found in B.

EXAMPLES

 sample program:

   program demo_ismember
   use M_sets, only: ismember
   character(len=*),parameter :: g='(*(g0,1x))'
   integer, allocatable       :: A(:)
   integer, allocatable       :: B(:)

      write(*,g) 'ISMEMBER', 'Determine which elements of A are also in B.'

       A=[5,3,4,2]
       B=[2,4,4,4,6,8]
       write(*,g) 'A=', A
       write(*,g) 'B=', B
       write(*,g) ismember(A,B)

   end program demo_ismember

Results:

 > ISMEMBER Determine which elements of A are also in B.
 > A= 5 3 4 2
 > B= 2 4 4 4 6 8
 > 0 0 1 1

AUTHORS
   John S. Urban, 2023-07-20

LICENSE
   CC0-1.0
$ENDBLOCK
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$PARCEL ISMEMBER_TEMPLATE
function ismember_${KIND}(A, B) result(answer)
! C = ismember(A,B) returns an array containing 1 (true) where the data in A is found in B. Elsewhere, the array contains 0
${TYPE}(kind=${KIND}), intent(in)   :: a(:)
${TYPE}(kind=${KIND}), intent(in)   :: b(:)
${TYPE}(kind=${KIND}), allocatable  :: ab(:)
integer, allocatable                :: answer(:)
integer, allocatable                :: iwrk1(:)
integer, allocatable                :: iwrk2(:)
integer                             :: inums
   inums=size(a)
   ab = [ a, unique(b) ] ! potentially a lot of memory
   if (allocated(iwrk2)) deallocate (iwrk2)
   allocate (iwrk2(size(a)))
   if (allocated(iwrk1)) deallocate (iwrk1)
   allocate (iwrk1(size(ab)))
   call occurrences_(ab, iwrk1)
   call occurrences_(a, iwrk2)
   answer=iwrk1(:inums)-iwrk2
   answer=merge(0,1,answer == 0)

end function ismember_${KIND}
$ENDPARCEL ISMEMBER_TEMPLATE
!-----------------------------------------------------------------------------------------------------------------------------------
function ismember_c(A, B) result(answer)
! C = ismember(A,B) returns an array containing 1 (true) where the data in A is found in B. Elsewhere, the array contains 0
character(len=*), intent(in)   :: a(:)
character(len=*), intent(in)   :: b(:)
integer         , allocatable  :: answer(:)
integer         , allocatable  :: iwrk1(:)
integer         , allocatable  :: iwrk2(:)
character(len=:), allocatable  :: cwrk1(:)
integer                        :: inums
integer                        :: longest
   longest=max(len(a),len(b))
   inums=size(a)
   cwrk1 = [ character(len=longest) :: a, unique(b) ] ! potentially a lot of memory
   if (allocated(iwrk2)) deallocate (iwrk2)
   allocate (iwrk2(size(a)))
   if (allocated(iwrk1)) deallocate (iwrk1)
   allocate (iwrk1(size(cwrk1)))
   call occurrences_(cwrk1, iwrk1)
   call occurrences_(a, iwrk2)
   answer=iwrk1(:inums)-iwrk2
   answer=merge(0,1,answer == 0)

end function ismember_c
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK COMMENT --file setxor.3m_sets.man
NAME
   setxor(3f) - [M_sets] Find values of A and B not in both arrays

SYNOPSIS

   setxor(A,B, setOrder)

DESCRIPTION

setxfor(3f) returns the exclusive OR of two arrays. That is, it returns
the data of A and B that are not in their intersection (the symmetric
difference), with no repetitions.

Another way of defining the result is that setxor(3f) returns the data
that occurs in A or B, but not both.

OPTIONS

    A         input array
    B         input array
    setOrder  May be "sort" or "stable". If "stable" the values are
              returned in the order discovered. The default is
              "sorted", which returns the data in ascending order.

EXAMPLES

 sample program:

   program demo_setxor
   use M_sets, only: setxor
   character(len=*),parameter :: g='(*(g0,1x))'
   integer, allocatable       :: A(:)
   integer, allocatable       :: B(:)

      write(*,g) 'SETXOR','Find values of A and B not in their intersection.'
      A = [5,1,3,3,3]
      B = [4,1,2]
      write(*,g) 'A=', A
      write(*,g) 'B=', B
      write(*,g) setxor(A,B)
      write(*,g) setxor(A,B,'stable')

   end program demo_setxor

Results:

 > SETXOR Find values of A and B not in their intersection.
 > A= 5 1 3 3 3
 > B= 4 1 2
 > 2 3 4 5
 > 5 3 4 2

AUTHORS
   John S. Urban, 2023-07-20

LICENSE
   CC0-1.0
$ENDBLOCK
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$PARCEL SETXOR_TEMPLATE
function setxor_${KIND}(A, B, setOrder) result(answer)
! C = setxor(A,B,setOrder) returns the data of A and B that are not in their intersection
!                          (the symmetric difference), with no repetitions. That is, setxor returns the
!                          data that occurs in A or B, but not both. C is in sorted order.
${TYPE}(kind=${KIND}), intent(in)      :: a(:)
${TYPE}(kind=${KIND}), intent(in)      :: b(:)
character(len=*), intent(in), optional :: setOrder
${TYPE}(kind=${KIND}), allocatable     :: answer(:)
integer, allocatable                   :: iwrk1(:)
integer, allocatable                   :: iwrk2(:)
integer, allocatable                   :: iwrk3(:)
integer                                :: inums
   inums=size(a)

   answer = [ a, b ] ! potentially a lot of memory
   if (allocated(iwrk1)) deallocate (iwrk1)
   allocate (iwrk1(size(answer)))
   call occurrences_(answer, iwrk1)

   if (allocated(iwrk2)) deallocate (iwrk2)
   allocate (iwrk2(size(a)))
   call occurrences_(a, iwrk2)

   if (allocated(iwrk3)) deallocate (iwrk3)
   allocate (iwrk3(size(b)))
   call occurrences_(b, iwrk3)

   iwrk1=iwrk1-[iwrk2,iwrk3]

   answer=pack(answer,iwrk1 == 0)
   answer=unique(answer,setOrder)

end function setxor_${KIND}
$ENDPARCEL SETXOR_TEMPLATE
!-----------------------------------------------------------------------------------------------------------------------------------
function setxor_c(A, B, setOrder) result(answer)
! C = setxor(A,B,setOrder) returns the data of A and B that are not in their intersection
!                          (the symmetric difference), with no repetitions. That is, setxor returns the
!                          data that occurs in A or B, but not both. C is in sorted order.
character(len=*), intent(in)           :: a(:)
character(len=*), intent(in)           :: b(:)
character(len=*), intent(in), optional :: setOrder
character(len=:), allocatable          :: answer(:), kludge(:)
integer         , allocatable          :: iwrk1(:)
integer         , allocatable          :: iwrk2(:)
integer         , allocatable          :: iwrk3(:)
integer                                :: inums
integer                                :: longest
   inums=size(a)
   longest=max(len(a),len(b))

   answer = [character(len=longest) ::  a, b ] ! potentially a lot of memory
   if (allocated(iwrk1)) deallocate (iwrk1)
   allocate (iwrk1(size(answer)))
   call occurrences_(answer, iwrk1)

   if (allocated(iwrk2)) deallocate (iwrk2)
   allocate (iwrk2(size(a)))
   call occurrences_(a, iwrk2)

   if (allocated(iwrk3)) deallocate (iwrk3)
   allocate (iwrk3(size(b)))
   call occurrences_(b, iwrk3)

   iwrk1=iwrk1-[iwrk2,iwrk3]

   kludge=pack(answer//'',iwrk1 == 0)
   answer=unique(kludge,setOrder)

end function setxor_c
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK COMMENT --file isequal.3m_sets.man
NAME
   isequal(3f) - [M_sets] Report if vector A is equal to vector B

SYNOPSIS

   isequal(A,B,TOLERANCE)

     character(len=:)intent(in) :: A,B
       or
     integer|real|complex(in) :: A,B
     real,optional            :: TOLERANCE

DESCRIPTION

   Report if A is equal to B. Equality is defined as the same element
   values in the same order. 

   A 1 (true) is returned when the elements of A have a one-to-one
   correspondence to the elements of B with the same values in the
   same order.  0 (false) is returned otherwise.

OPTIONS

    A          input array to compare against
    B          input array to compare to A
    TOLERANCE  for numeric values consider the corresponding elements
               of A and B equal if they are equal within the specified
	       tolerance.

    A,B and TOLERANCE are of the same type and kind.

RETURNS

    1 if input array A is to array B, 0 otherwise

EXAMPLES

 sample program:

   program demo_isequal
   use M_sets, only: isequal
   character(len=*),parameter :: g='(*(g0,1x))'
   integer,allocatable        :: A(:)
   integer,allocatable        :: B(:)

   write(*,g) 'isequal','Find if A is equal to B. '
       A = [10, -10, 0, 1, 2, 3, 3, 2, 1,-10]
       B = [10, -10, 0, 1, 2, 3, 3, 2, 1, 10]
       write(*,g) 'A=', A
       write(*,g) 'B=', B
       write(*,g) isequal(A,B)
   write(*,g) 'isequal','Find if A is equal to A. '
       write(*,g) isequal(A,A)

   end program demo_isequal

Results:

 > isequal Find the isequal elements of vector A.
 > A= 10 -10 0 1 2 3 3 2 1 -10
 > 0
 > A= -10 10 100 201
 > 1

AUTHORS
   John S. Urban, 2023-07-20

LICENSE
   CC0-1.0
$ENDBLOCK
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$PARCEL isequal_TEMPLATE
function isequal_${KIND}(A,B,TOLERANCE) result(answer)
! TF = isequal(A) returns the logical scalar 1 (true) when the elements of A are identical to elementsof B or  0 (false) otherwise.
${TYPE}(kind=${KIND}), intent(in)           :: A(:)
${TYPE}(kind=${KIND}), intent(in)           :: B(:)
${TYPE}(kind=${KIND}), intent(in), optional :: TOLERANCE
${TYPE}(kind=${KIND})                       :: DELTA
integer                                     :: answer
integer                                     :: i
answer=1
if(present(tolerance))then
   delta=tolerance
else
   delta=0
endif
if(size(A).eq.size(B))then
   ! A merge() might not short-circuit or make copies?
   if(delta.eq.0)then
      do i=1,size(A)
         if(A(i) /= B(i))then
            answer=0
            exit
         endif
      enddo
   else
      do i=1,size(A)
         if(abs(A(i)- B(i)).gt.delta)then
            answer=0
            exit
         endif
      enddo
   endif
else
   answer=0
endif
end function isequal_${KIND}
$ENDPARCEL isequal_TEMPLATE
!-----------------------------------------------------------------------------------------------------------------------------------
function isequal_c(A,B) result(answer)
! TF = isequal(A) returns the logical scalar 1 (true) when the elements of A are listed in ascending order and 0 (false) otherwise.
character(len=*), intent(in) :: A(:)
character(len=*), intent(in) :: B(:)
integer                      :: answer
integer                      :: i
answer=1
if(size(A).eq.size(B))then
   ! A merge() might not short-circuit or make copies?
   do i=1,size(A)
      if(A(i) /= B(i))then
         answer=0
         exit
      endif
   enddo
else
   answer=0
endif
end function isequal_c
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK COMMENT --file issorted.3m_sets.man
NAME
   issorted(3f) - [M_sets] Report if A is sorted in ascending order or not.

SYNOPSIS

   issorted(A)

     character(len=:)intent(in) :: A
       or
     integer|real|complex(in) :: A

DESCRIPTION

   Report if A is sorted in ascending order or not. A 1 (true) is
   returned when the elements of A are listed in ascending order and 0
   (false) otherwise.

OPTIONS

    A         input array to test

RETURNS

    1 if input array A is sorted in ascending order, 0 otherwise

EXAMPLES

 sample program:

   program demo_issorted
   use M_sets, only: issorted
   character(len=*),parameter :: g='(*(g0,1x))'
   integer,allocatable        :: A(:)

      write(*,g) 'ISSORTED','Find the issorted elements of vector A.'
       A = [10, -10, 0, 1, 2, 3, 3, 2, 1, -10]
       write(*,g) 'A=', A
       write(*,g) issorted(A)
       A = [-10, 10, 100, 201]
       write(*,g) 'A=', A
       write(*,g) issorted(A)

   end program demo_issorted

Results:

 > ISSORTED Find the issorted elements of vector A.
 > A= 10 -10 0 1 2 3 3 2 1 -10
 > 0
 > A= -10 10 100 201
 > 1

AUTHORS
   John S. Urban, 2023-07-20

LICENSE
   CC0-1.0
$ENDBLOCK
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$PARCEL ISSORTED_TEMPLATE
function issorted_${KIND}(A) result(answer)
! TF = issorted(A) returns the logical scalar 1 (true) when the elements of A are listed in ascending order and 0 (false) otherwise.
${TYPE}(kind=${KIND}), intent(in) :: A(:)
integer                           :: answer
integer                           :: i
answer=1
do i=1,size(a)-1
   if(A(i) > A(i+1))then
      answer=0
      exit
   endif
enddo
end function issorted_${KIND}
$ENDPARCEL ISSORTED_TEMPLATE
!-----------------------------------------------------------------------------------------------------------------------------------
function issorted_c(A) result(answer)
! TF = issorted(A) returns the logical scalar 1 (true) when the elements of A are listed in ascending order and 0 (false) otherwise.
character(len=*), intent(in) :: A(:)
integer                      :: answer
integer                      :: i
answer=1
do i=1,size(a)-1
   if(A(i) > A(i+1))then
      answer=0
      exit
   endif
enddo
end function issorted_c
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
elemental pure function lower(str) result (string)

$@(#) M_strings::lower(3f): Changes a string to lowercase

character(*), intent(in)    :: str
character(len(str))         :: string
integer                     :: i
integer,parameter           :: diff = iachar('A')-iachar('a')

   string = str

   do concurrent (i = 1:len_trim(str))                ! step thru each letter in the string in specified range

      select case (str(i:i))
      case ('A':'Z')
         string(i:i) = achar(iachar(str(i:i))-diff)   ! change letter to miniscule
      case default
      end select

   enddo

end function lower
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$PARCEL SPACE

$ENDPARCEL SPACE

$PARCEL PROCEDURES
$POST SPACE
$POST UNIQUE_TEMPLATE
$POST SPACE
$POST UNION_TEMPLATE
$POST SPACE
$POST INTERSECT_TEMPLATE
$POST SPACE
$POST SETDIFF_TEMPLATE
$POST SPACE
$POST ISMEMBER_TEMPLATE
$POST SPACE
$POST SETXOR_TEMPLATE
$POST SPACE
$POST ISSORTED_TEMPLATE
$POST SPACE
$POST ISEQUAL_TEMPLATE
$ENDPARCEL PROCEDURES

$!>>> INTEGER
$set TYPE integer
$set KIND int8
$POST PROCEDURES
$set KIND int16
$POST PROCEDURES
$set KIND int32
$POST PROCEDURES
$set KIND int64
$POST PROCEDURES
$!>>> REAL
$set TYPE real
$set KIND real32
$POST PROCEDURES
$set KIND real64
$POST PROCEDURES
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK COMMENT --file bool.3m_sets.man
NAME
   bool(3f) - [M_sets::LOGICAL] returns One if expression is TRUE,
   else returns Zero.
   (LICENSE:PD)
SYNOPSIS

   pure elemental integer function bool(expr)

    logical,intent(in) :: expr
      or
    character(len=:)intent(in) :: expr
      or
    integer|real|complex(in) :: expr

DESCRIPTION

   bool(3f) returns an integer 1 given a true logical expression.

OPTIONS
expr  A logical expression. If any other intrinsic type a blank string is
      TRUE as well as 0. 0.0, and (0.0,0.0). Non-zero numeric values
      and non-blank or non-null strings are FALSE.

RETURNS

  The result is a default INTEGER value of 1 if the expression is TRUE,
  and a 0 otherwise.

EXAMPLES
 Sample usage:

   program demo_bool
   use M_sets, only: bool
   implicit none
      write (*, *) 'is 10 < 20 ?', bool(10 < 20)
      write (*, *) 'elemental', bool([2 > 1, 3 == 4, 10 < 5, 100 > 50])
      if (sum(bool([2 > 1, 3 == 4, 10 < 5, 100 > 50])) >= 2) then
         write (*, *) 'two or more are true'
      endif
   end program demo_bool

 Results:

    > is 10 < 20 ? 1
    > elemental 1 0 0 1
    > two or more are true

AUTHOR
   John S. Urban
LICENSE
   CC0-1.0
$BLOCK END
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
pure elemental integer function bool_expr(expr)
$@(#) M_sets::bool(3f): logical to integer, TRUE results in 1, FALSE results in 0
logical, intent(in) :: expr
   bool_expr = merge(1, 0, expr) ! One and Zero
end function bool_expr

pure elemental integer function bool_int8(int);  integer(kind=int8),intent(in)  :: int; bool_int8  = merge(1,0,int==0); end
pure elemental integer function bool_int16(int); integer(kind=int16),intent(in) :: int; bool_int16 = merge(1,0,int==0); end
pure elemental integer function bool_int32(int); integer(kind=int32),intent(in) :: int; bool_int32 = merge(1,0,int==0); end
pure elemental integer function bool_int64(int); integer(kind=int64),intent(in) :: int; bool_int64 = merge(1,0,int==0); end

pure elemental integer function bool_float32(float); real(kind=real32),intent(in) :: float; bool_float32=merge(1,0,float==0.0); end
pure elemental integer function bool_float64(float); real(kind=real64),intent(in) :: float; bool_float64=merge(1,0,float==0.0); end

pure elemental integer function bool_complex32(val)
complex(kind=real32),intent(in) :: val
   bool_complex32=merge(1,0,abs(val)==0.0_real32)
end function bool_complex32

pure elemental integer function bool_complex64(val)
complex(kind=real64),intent(in) :: val
   bool_complex64=merge(1,0,abs(val)==0.0_real64)
end function bool_complex64

pure elemental integer function bool_char(string)
character(len=*),intent(in) :: string
   bool_char=merge(1,0,string=='')
end function bool_char

end module M_sets
