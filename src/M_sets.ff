module M_sets
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK COMMENT --file M_sets.3m_sets.man
NAME
   M_sets(3f) - [M_sets::INTRO] functions reminiscent of Matlab set
   functions

SYNOPSIS
   Procedure names and syntax:

    use M_sets, only : &
    union, unique, intersect, setdiff, ismember, setxor
    use M_sets, only : &
    issorted

DESCRIPTION

Set operations compare the elements in two sets to find commonalities
or differences. This includes Unions, Intersections, and Membership.

M_set(3f) is a Fortran module comprising a small subset of set theory
functions reminiscent of Matlab functions.

The functions currently only support vectors of integer and default
character type.

float numbers (both kind=real32 and kind=real64) are allowed but "caveat
emptor", as comparing floats for equality has issues. You may have to
condition the float data by converting it to scaled integers or using
intrinsics such as NEAREST(3f) to produce the desired results.

M_set(3f) primarily uses simple calls to the M_ordersort(3f) module to
provide the functionality. The functions  are not otherwise tuned for
performance and make loose use of memory allocation but are sufficient
for most uses, simple to use, and familiar to a large base of users.

## Functions
 + union(A,B,setOrder)     - Join two sets and remove duplicates of values
 + unique(A,setOrder)      - Remove duplicates of values from a set
 + intersect(A,B,setOrder) - Find the values common to both A and B
 + setdiff(A,B,setOrder)   - Find the values in A that are not in B
 + ismember(A,B,setOrder)  - Create a mask of A marking elements also in B
 + setxor(A,B,setOrder)    - Find values of A and B not in both arrays
 + issorted(A)             - Determine if array is already sorted

 The subsequent data may be produced sorted, or left in the order
 encountered.

EXAMPLE

 sample program:

   program demo_M_sets
   use M_sets, only: &
   & unique, intersect, union, setdiff, ismember, setxor, issorted
   character(len=*),parameter :: g='(*(g0,1x))'
   integer,allocatable        :: A(:)
   integer,allocatable        :: B(:)
   integer,allocatable        :: C(:)

      write(*,g) 'UNIQUE','Find the unique elements of vector A.'
       A = [10, -10, 0, 1, 2, 3, 3, 2, 1, -10]
       write(*,g) 'A=', A
       write(*,g) unique(A)
       write(*,g) unique(A, setOrder='stable')
      write(*,g) 'UNION', 'Find the union of vectors A and B.'
       call setab( [5, 7, 1], [3, 1, 1] )
       write(*,g) union(A,B)
       call setab( [5, 5, 3], [1, 2, 5] )
       write(*,g) union(A, B, 'sorted')
       write(*,g) union(A, B, 'stable')
      write(*,g) 'INTERSECT', 'Find the values common to both A and B.'
       call setab( [7, 1, 7, 7, 4], [7, 0, 4, 4, 0] )
       write(*,g) intersect(A, B)
       write(*,g) intersect(A, B, setOrder='stable')
      write(*,g) 'SETDIFF','Find the values in A that are not in B.'
       call setab( [3, 6, 2, 1, 5, 1, 1], [2, 4, 6] )
       write(*,g) setdiff(A, B)
       call setab( [4, 1, 3, 2, 5], [2, 1])
       write(*,g) setdiff(A, B, 'sorted')
       write(*,g) setdiff(A, B, 'stable')
      write(*,g) 'ISMEMBER', &
      'Determine which elements of A are also in B.'
       call setab( [5,3,4,2], [2,4,4,4,6,8] )
       write(*,g) ismember(A,B)
      write(*,g) 'SETXOR',&
      'Find values of A and B not in their intersection.'
       call setab( [5,1,3,3,3], [4,1,2] )
       write(*,g) setxor(A,B)
       write(*,g) setxor(A,B,'stable')

       write(*,g) 'ISSSORTED',&
       'confirm whether array is sorted in ascending order or not'
       call setab([1,2,3,4,5],[5,4,3,2,1])
       write(*,g) issorted(A)
       write(*,g) issorted(B)

   contains
   subroutine setab(ain,bin)
   integer,intent(in) :: ain(:)
   integer,intent(in) :: bin(:)
      A=ain
      B=bin
      write(*,g) 'A=', A
      write(*,g) 'B=', B
   end subroutine setab

   end program demo_M_sets

Results:

 > UNIQUE Find the unique elements of vector A.
 > A= 10 -10 0 1 2 3 3 2 1 -10
 > -10 0 1 2 3 10
 > 10 -10 0 1 2 3
 > UNION Find the union of vectors A and B.
 > A= 5 7 1
 > B= 3 1 1
 > 1 3 5 7
 > A= 5 5 3
 > B= 1 2 5
 > 1 2 3 5
 > 5 3 1 2
 > INTERSECT Find the values common to both A and B.
 > A= 7 1 7 7 4
 > B= 7 0 4 4 0
 > 4 7
 > 7 4
 > SETDIFF Find the values in A that are not in B.
 > A= 3 6 2 1 5 1 1
 > B= 2 4 6
 > 1 3 5
 > A= 4 1 3 2 5
 > B= 2 1
 > 3 4 5
 > 4 3 5
 > ISMEMBER Determine which elements of A are also in B.
 > A= 5 3 4 2
 > B= 2 4 4 4 6 8
 > 0 0 1 1
 > SETXOR Find values of A and B not in their intersection.
 > A= 5 1 3 3 3
 > B= 4 1 2
 > 2 3 4 5
 > 5 3 4 2

AUTHORS
   John S. Urban, 2023-07-20

LICENSE
   CC0-1.0
$ENDBLOCK
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
! a subset of the functionality of set functions in Matlab are provided.
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64
use,intrinsic :: iso_fortran_env, only : real32,real64,real128
use M_orderpack, only: unique_ => unique, occurrences_ => occurrences, sort_ => sort
use M_orderpack, only: rank_unique_ => rank_unique

private

public :: unique    ! C = unique(A,setOrder)      returns the same data as in A, but with no repetitions.
public :: union     ! C = union(A,B,setOrder)     returns the combined data from A and B with no repetitions.
public :: intersect ! C = intersect(A,B,setOrder) returns the data common to both A and B, with no repetitions.
public :: setdiff   ! C = setdiff(A,B,setOrder)   returns the data in A that is not in B, with no repetitions.
public :: ismember  ! C = ismember(A,B) returns   an array containing 1 (true) where the data in A is found in B. Elsewhere, 0.
public :: setxor    ! C = setxor(A,B,setOrder)    returns the data of A and B that are not in their intersection
                    !                             (the symmetric difference), with no repetitions. That is, setxor returns the
                    !                             data that occurs in A or B, but not both. C is in sorted order.
public :: issorted  ! C = issorted(A)             determine if A is in ascending order or not

$PARCEL MODULARIZE

interface unique;    module procedure unique_${KIND};    end interface unique
interface union;     module procedure union_${KIND};     end interface union
interface intersect; module procedure intersect_${KIND}; end interface intersect
interface setdiff;   module procedure setdiff_${KIND};   end interface setdiff
interface ismember;  module procedure ismember_${KIND};  end interface ismember
interface setxor;    module procedure setxor_${KIND};    end interface setxor
interface issorted;  module procedure issorted_${KIND};  end interface issorted
$ENDPARCEL MODULARIZE
$set KIND c
$POST MODULARIZE
$set KIND int8
$POST MODULARIZE
$set KIND int16
$POST MODULARIZE
$set KIND int32
$POST MODULARIZE
$set KIND int64
$POST MODULARIZE
$set KIND real32
$POST MODULARIZE
$set KIND real64
$POST MODULARIZE

contains

$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK COMMENT --file unique.3m_sets.man
NAME
   unique(3f) - [M_sets] return unique values in array A

SYNOPSIS

   unique(A,setOrder)

DESCRIPTION

unique(3) returns the unique values found in an array. That is, it
eliminates all but one occurrence of each value.

The result is in sorted order by default, but may be returned in the
order found.

OPTIONS

    A         input array to extract unique values from
    setOrder  May be "sort" or "stable". If "stable" the values are
              returned in the order discovered. The default is 
	      "sorted", which returns the data in ascending order.

RETURNS

    All the values that occur in the input occur in the output 
    just once. All duplicates are removed.

EXAMPLE

 sample program:

   program demo_unique
   use M_sets, only: unique
   character(len=*),parameter :: g='(*(g0,1x))'
   integer,allocatable        :: A(:)

      write(*,g) 'UNIQUE','Find the unique elements of vector A.'
       A = [10, -10, 0, 1, 2, 3, 3, 2, 1, -10]
       write(*,g) 'A=', A
       write(*,g) unique(A)
       write(*,g) unique(A, setOrder='stable')

   end program demo_unique

Results:

 > UNIQUE Find the unique elements of vector A.
 > A= 10 -10 0 1 2 3 3 2 1 -10
 > -10 0 1 2 3 10
 > 10 -10 0 1 2 3

AUTHORS
   John S. Urban, 2023-07-20

LICENSE
   CC0-1.0
$ENDBLOCK
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$PARCEL UNIQUE_TEMPLATE
function unique_${KIND}(A, setOrder) result(result)
! C = unique(A) returns the same data as in A, but with no repetitions. C is in sorted order.
${TYPE}(kind=${KIND}), intent(in)                    :: A(:)
character(len=*), intent(in), optional :: setOrder
${TYPE}(kind=${KIND}),allocatable      :: result(:)
integer,allocatable                    :: indices(:)
character(len=:), allocatable          :: setOrder_
integer                                :: nuni

   if (present(setOrder)) then
      setOrder_ = setOrder
   else
      setOrder_ = 'sorted'
   end if
   result = A
   select case (lower(setOrder_))
   case ('stable')
      call unique_(result, nuni)
      result = result(:nuni)
   case ('sorted')
      if (allocated(indices)) deallocate (indices)
      allocate (indices(size(A)))
      call rank_unique_(A, indices, nuni)
      result = A(indices(:nuni))
   case default
      stop '*unique* unknown setOrder '//setOrder_//'allowed are "stable" and "sorted"'
   end select
end function unique_${KIND}
$ENDPARCEL UNIQUE_TEMPLATE
!-----------------------------------------------------------------------------------------------------------------------------------
function unique_c(A, setOrder) result(result)
! C = unique(A) returns the same data as in A, but with no repetitions. C is in sorted order.
character(len=*), intent(in)           :: A(:)
character(len=*), intent(in), optional :: setOrder
character(len=:), allocatable          :: result(:)
character(len=:), allocatable          :: setOrder_
integer                                :: nuni
   if (present(setOrder)) then
      setOrder_ = setOrder
   else
      setOrder_ = 'sorted'
   endif
   result = A
   call unique_(result, nuni)
   result = result(:nuni)
   select case (lower(setOrder_))
   case ('stable')
   case ('sorted')
      call sort_(result)
   case default
      stop '*unique* unknown setOrder '//setOrder_//' allowed are "stable" and "sorted"'
   end select
end function unique_c
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK COMMENT --file union.3m_sets.man
NAME
   union(3f) - [M_sets] Join two sets and removes duplicates of values

SYNOPSIS

   union(A,B, setOrder)

DESCRIPTION

The two sets are combined and repetitions are removed. 

OPTIONS

    A         input array
    B         input array
    setOrder  May be "sort" or "stable". If "stable" the values are
              returned in the order discovered. The default is 
	      "sorted", which returns the data in ascending order.

EXAMPLE

 sample program:

   program demo_union
   use M_sets, only: union
   character(len=*),parameter :: g='(*(g0,1x))'
   integer,allocatable        :: A(:)
   integer,allocatable        :: B(:)

      write(*,g) 'UNION', 'Find the union of vectors A and B.'
      A=[5, 7, 1]
      B=[3, 1, 1]
      write(*,g) 'A=', A
      write(*,g) 'B=', B
      write(*,g) union(A,B)

      A=[5, 5, 3]
      B=[1, 2, 5]
      write(*,g) 'A=', A
      write(*,g) 'B=', B
      write(*,g) union(A, B, 'sorted')
      write(*,g) union(A, B, 'stable')

   end program demo_union
```
Results:

 > UNION Find the union of vectors A and B.
 > A= 5 7 1
 > B= 3 1 1
 > 1 3 5 7
 > A= 5 5 3
 > B= 1 2 5
 > 1 2 3 5
 > 5 3 1 2

AUTHORS
   John S. Urban, 2023-07-20

LICENSE
   CC0-1.0
$ENDBLOCK
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$PARCEL UNION_TEMPLATE
function union_${KIND}(A, B, setOrder) result(result)
! C = union(A,B) returns the combined data from A and B with no repetitions. C is in sorted order.
${TYPE}(kind=${KIND}),intent(in)         :: A(:)
${TYPE}(kind=${KIND}),intent(in)         :: B(:)
character(len=*),intent(in), optional  :: setOrder
${TYPE}(kind=${KIND}),allocatable        :: result(:)
   result = unique([A, B], setOrder)
end function union_${KIND}
$ENDPARCEL UNION_TEMPLATE
!-----------------------------------------------------------------------------------------------------------------------------------
function union_c(A, B, setOrder) result(result)
! C = union(A,B) returns the combined data from A and B with no repetitions. C is in sorted order.
character(len=*), intent(in)           :: A(:)
character(len=*), intent(in)           :: B(:)
character(len=*), intent(in), optional :: setOrder
character(len=:), allocatable          :: result(:)
character(len=:), allocatable          :: kludge(:)
integer                                :: longest
longest=max(len(a),len(b))
   kludge = [character(len=longest) :: A, B]
   result = unique(kludge, setOrder)
end function union_c
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK COMMENT --file intersect.3m_sets.man
NAME
   intersect(3f) - [M_sets] Find the values common to both sets A and B

SYNOPSIS

   intersect(A,B, setOrder)

DESCRIPTION

The values that occur at least once in each set are returned.

That is, intersect(3f) returns the data common to both A and B, with
no repetitions.

OPTIONS

    A         input array
    B         input array
    setOrder  May be "sort" or "stable". If "stable" the values are
              returned in the order discovered. The default is 
	      "sorted", which returns the data in ascending order.

EXAMPLE

 sample program:

  program demo_intersect
  use M_sets, only: unique, intersect, union, setdiff, ismember, setxor
  character(len=*),parameter :: g='(*(g0,1x))'
  integer, allocatable      :: A(:)
  integer, allocatable      :: B(:)

     write(*,g) 'INTERSECT', 'Find the values common to both A and B.'
      A=[7, 1, 7, 7, 4]
      B=[7, 0, 4, 4, 0]
      write(*,g) 'A=', A
      write(*,g) 'B=', B
      write(*,g) intersect(A, B)
      write(*,g) intersect(A, B, setOrder='stable')
  end program demo_intersect

Results:

 > INTERSECT Find the values common to both A and B.
 > A= 7 1 7 7 4
 > B= 7 0 4 4 0
 > 4 7
 > 7 4

AUTHORS
   John S. Urban, 2023-07-20

LICENSE
   CC0-1.0
$ENDBLOCK
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$PARCEL INTERSECT_TEMPLATE
function intersect_${KIND}(A, B, setOrder) result(result)
! C = intersect(A,B) returns the data common to both A and B, with no repetitions. C is in sorted order by default
${TYPE}(kind=${KIND}), intent(in)                    :: A(:)
${TYPE}(kind=${KIND}), intent(in)                    :: B(:)
character(len=*), intent(in), optional :: setOrder
${TYPE}(kind=${KIND}), allocatable                   :: result(:)
integer, allocatable                                 :: iwrk(:)
   result = [unique(A, setOrder), unique(B, setOrder)]
   if (allocated(iwrk)) deallocate (iwrk)
   allocate (iwrk(size(result)))
   call occurrences_(result, iwrk)
   result = unique(pack(result, iwrk .gt. 1), setOrder)
end function intersect_${KIND}
$ENDPARCEL INTERSECT_TEMPLATE
!-----------------------------------------------------------------------------------------------------------------------------------
function intersect_c(A, B, setOrder) result(result)
! C = intersect(A,B) returns the data common to both A and B, with no repetitions. C is in sorted order by default
character(len=*), intent(in)           :: A(:)
character(len=*), intent(in)           :: B(:)
character(len=*), intent(in), optional :: setOrder
character(len=:), allocatable          :: result(:)
integer, allocatable                   :: iwrk(:)
character(len=:), allocatable          :: kludge(:)
integer                                :: longest
   longest=max(len(A),len(B))
   result = [character(len=longest) :: unique(A, setOrder), unique(B, setOrder)]
   if (allocated(iwrk)) deallocate (iwrk)
   allocate (iwrk(size(result)))
   call occurrences_(result, iwrk)
   !--------------------------------
   !result= unique(pack(result//'',iwrk.gt.1),setOrder) ! add //' ' to avoid gfortran 13.1.0-8 bug
   kludge=pack(result//'',iwrk.gt.1)
   result = unique(kludge, setOrder)
   !--------------------------------
end function intersect_c
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK COMMENT --file setdiff.3m_sets.man
NAME
   setdiff(3f) - [M_sets] Find the values in A that are not in B

SYNOPSIS

   setdiff(A,B, setOrder)

DESCRIPTION

setdiff(3f) returns the data in A that is not in B, with no repetitions.

OPTIONS

    A         input array
    B         input array
    setOrder  May be "sort" or "stable". If "stable" the values are
              returned in the order discovered. The default is 
	      "sorted", which returns the data in ascending order.

EXAMPLE

 sample program:

   program demo_setdiff
   use M_sets, only: setdiff
   character(len=*),parameter :: g='(*(g0,1x))'
   integer, allocatable      :: A(:)
   integer, allocatable      :: B(:)

      write(*,g) 'SETDIFF','Find the values in A that are not in B.'
       A=[3, 6, 2, 1, 5, 1, 1]
       B=[2, 4, 6]
       write(*,g) 'A=', A
       write(*,g) 'B=', B
       write(*,g) setdiff(A, B)
       write(*,g) setdiff([4, 1, 3, 2, 5], [2, 1], 'sorted')
       write(*,g) setdiff([4, 1, 3, 2, 5], [2, 1], 'stable')

   end program demo_setdiff

Results:

 > SETDIFF Find the values in A that are not in B.
 > A= 3 6 2 1 5 1 1
 > B= 2 4 6
 > 1 3 5
 > 3 4 5
 > 4 3 5

AUTHORS
   John S. Urban, 2023-07-20

LICENSE
   CC0-1.0
$ENDBLOCK
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$PARCEL SETDIFF_TEMPLATE
function setdiff_${KIND}(A, B, setOrder) result(result)
! C = setdiff(A,B) returns the data in A that is not in B, with no repetitions. C is in sorted order by default.
${TYPE}(kind=${KIND}), intent(in)                    :: a(:)
${TYPE}(kind=${KIND}), intent(in)                    :: b(:)
character(len=*), intent(in), optional :: setOrder
${TYPE}(kind=${KIND}), allocatable                   :: result(:)
integer, allocatable                                 :: iwrk(:)
   result = unique(b, setOrder='stable')
   result = [unique(a, setOrder='stable'), result, result] ! potentially a lot of memory
   if (allocated(iwrk)) deallocate (iwrk)
   allocate (iwrk(size(result)))
   call occurrences_(result, iwrk)
   result = unique(pack(result, iwrk .eq. 1), setOrder)

end function setdiff_${KIND}
$ENDPARCEL SETDIFF_TEMPLATE
!-----------------------------------------------------------------------------------------------------------------------------------
function setdiff_c(A, B, setOrder) result(result)
! C = setdiff(A,B) returns the data in A that is not in B, with no repetitions. C is in sorted order by default.
character(len=*), intent(in)           :: a(:)
character(len=*), intent(in)           :: b(:)
character(len=*), intent(in), optional :: setOrder
character(len=:), allocatable          :: result(:),kludge(:)
integer         , allocatable          :: iwrk(:)
integer                                :: longest
   result = unique(b, setOrder='stable')
   longest=max(len(a),len(b))
   result = [character(len=longest) :: unique(a, setOrder='stable'), result, result] ! potentially a lot of memory
   if (allocated(iwrk)) deallocate (iwrk)
   allocate ( iwrk(size(result)))
   call occurrences_(result, iwrk)
   !--------------------------------
   !result = unique(pack(result, iwrk .eq. 1), setOrder)
   kludge = pack(result//'', iwrk .eq. 1)
   result = unique(kludge, setOrder)
   !--------------------------------

end function setdiff_c
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK COMMENT --file ismember.3m_sets.man
NAME
   ismember(3f) - [M_sets] Create a mask of A marking elements also in B

SYNOPSIS

   ismember(A,B)

DESCRIPTION

Identifies elements of the first set that are members of the second set
as well.

The returned array is a mask of the first array containing a 1
(aka. "true") where the data in A is found in B. Elsewhere, the array
contains 0 (aka. "false").

OPTIONS

    A         input array
    B         input array of values to find in vector A.

RETURNS
    A mask of array A with a 1 at locations where the value in that
    position in A is also a value that occurs in B, and with a 0 at
    locations where that value in A was not found in B.

EXAMPLE

 sample program:

   program demo_ismember
   use M_sets, only: ismember
   character(len=*),parameter :: g='(*(g0,1x))'
   integer, allocatable      :: A(:)
   integer, allocatable      :: B(:)

      write(*,g) 'ISMEMBER', 'Determine which elements of A are also in B.'

       A=[5,3,4,2]
       B=[2,4,4,4,6,8]
       write(*,g) 'A=', A
       write(*,g) 'B=', B
       write(*,g) ismember(A,B)

   end program demo_ismember

Results:

 > ISMEMBER Determine which elements of A are also in B.
 > A= 5 3 4 2
 > B= 2 4 4 4 6 8
 > 0 0 1 1

AUTHORS
   John S. Urban, 2023-07-20

LICENSE
   CC0-1.0
$ENDBLOCK
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$PARCEL ISMEMBER_TEMPLATE
function ismember_${KIND}(A, B) result(result)
! C = ismember(A,B) returns an array containing 1 (true) where the data in A is found in B. Elsewhere, the array contains 0
${TYPE}(kind=${KIND}), intent(in)   :: a(:)
${TYPE}(kind=${KIND}), intent(in)   :: b(:)
${TYPE}(kind=${KIND}), allocatable  :: result(:)
integer, allocatable                :: iwrk1(:)
integer, allocatable                :: iwrk2(:)
integer                             :: inums
   inums=size(a)
   result = [ a, unique(b) ] ! potentially a lot of memory
   if (allocated(iwrk2)) deallocate (iwrk2)
   allocate (iwrk2(size(a)))
   if (allocated(iwrk1)) deallocate (iwrk1)
   allocate (iwrk1(size(result)))
   call occurrences_(result, iwrk1)
   call occurrences_(a, iwrk2)
   result=iwrk1(:inums)-iwrk2
   result=merge(0,1,result.eq.0)

end function ismember_${KIND}
$ENDPARCEL ISMEMBER_TEMPLATE
!-----------------------------------------------------------------------------------------------------------------------------------
function ismember_c(A, B) result(result)
! C = ismember(A,B) returns an array containing 1 (true) where the data in A is found in B. Elsewhere, the array contains 0
character(len=*), intent(in)   :: a(:)
character(len=*), intent(in)   :: b(:)
integer         , allocatable  :: result(:)
integer         , allocatable  :: iwrk1(:)
integer         , allocatable  :: iwrk2(:)
character(len=:), allocatable  :: cwrk1(:)
integer                        :: inums
integer                        :: longest
   longest=max(len(a),len(b))
   inums=size(a)
   cwrk1 = [ character(len=longest) :: a, unique(b) ] ! potentially a lot of memory
   if (allocated(iwrk2)) deallocate (iwrk2)
   allocate (iwrk2(size(a)))
   if (allocated(iwrk1)) deallocate (iwrk1)
   allocate (iwrk1(size(cwrk1)))
   call occurrences_(cwrk1, iwrk1)
   call occurrences_(a, iwrk2)
   result=iwrk1(:inums)-iwrk2
   result=merge(0,1,result.eq.0)

end function ismember_c
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK COMMENT --file setxor.3m_sets.man
NAME
   setxor(3f) - [M_sets] Find values of A and B not in both arrays

SYNOPSIS

   setxor(A,B, setOrder)

DESCRIPTION

setxfor(3f) returns the exclusive OR of two arrays.  That is, it returns
the data of A and B that are not in their intersection (the symmetric
difference), with no repetitions.

Another way of defining the result is that setxor(3f) returns the data
that occurs in A or B, but not both.

OPTIONS

    A         input array
    B         input array
    setOrder  May be "sort" or "stable". If "stable" the values are
              returned in the order discovered. The default is 
	      "sorted", which returns the data in ascending order.

EXAMPLE

 sample program:

   program demo_setxor
   use M_sets, only: setxor
   character(len=*),parameter :: g='(*(g0,1x))'
   integer, allocatable      :: A(:)
   integer, allocatable      :: B(:)

      write(*,g) 'SETXOR','Find values of A and B not in their intersection.'
      A = [5,1,3,3,3]
      B = [4,1,2]
      write(*,g) 'A=', A
      write(*,g) 'A=', B
      write(*,g) setxor(A,B)
      write(*,g) setxor(A,B,'stable')

   end program demo_setxor

Results:

 > SETXOR Find values of A and B not in their intersection.
 > A= 5 1 3 3 3
 > A= 4 1 2
 > 2 3 4 5
 > 5 3 4 2

AUTHORS
   John S. Urban, 2023-07-20

LICENSE
   CC0-1.0
$ENDBLOCK
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$PARCEL SETXOR_TEMPLATE
function setxor_${KIND}(A, B, setOrder) result(result)
! C = setxor(A,B,setOrder) returns the data of A and B that are not in their intersection
!                          (the symmetric difference), with no repetitions. That is, setxor returns the
!                          data that occurs in A or B, but not both. C is in sorted order.
${TYPE}(kind=${KIND}), intent(in)                    :: a(:)
${TYPE}(kind=${KIND}), intent(in)                    :: b(:)
character(len=*), intent(in), optional :: setOrder
${TYPE}(kind=${KIND}), allocatable                   :: result(:)
integer, allocatable                                 :: iwrk1(:)
integer, allocatable                                 :: iwrk2(:)
integer, allocatable                                 :: iwrk3(:)
integer                                :: inums
   inums=size(a)

   result = [ a, b ] ! potentially a lot of memory
   if (allocated(iwrk1)) deallocate (iwrk1)
   allocate (iwrk1(size(result)))
   call occurrences_(result, iwrk1)

   if (allocated(iwrk2)) deallocate (iwrk2)
   allocate (iwrk2(size(a)))
   call occurrences_(a, iwrk2)

   if (allocated(iwrk3)) deallocate (iwrk3)
   allocate (iwrk3(size(b)))
   call occurrences_(b, iwrk3)

   iwrk1=iwrk1-[iwrk2,iwrk3]

   result=pack(result,iwrk1.eq.0)
   result=unique(result,setOrder)

end function setxor_${KIND}
$ENDPARCEL SETXOR_TEMPLATE
!-----------------------------------------------------------------------------------------------------------------------------------
function setxor_c(A, B, setOrder) result(result)
! C = setxor(A,B,setOrder) returns the data of A and B that are not in their intersection
!                          (the symmetric difference), with no repetitions. That is, setxor returns the
!                          data that occurs in A or B, but not both. C is in sorted order.
character(len=*), intent(in)           :: a(:)
character(len=*), intent(in)           :: b(:)
character(len=*), intent(in), optional :: setOrder
character(len=:), allocatable          :: result(:), kludge(:)
integer         , allocatable          :: iwrk1(:)
integer         , allocatable          :: iwrk2(:)
integer         , allocatable          :: iwrk3(:)
integer                                :: inums
integer                                :: longest
   inums=size(a)
   longest=max(len(a),len(b))

   result = [character(len=longest) ::  a, b ] ! potentially a lot of memory
   if (allocated(iwrk1)) deallocate (iwrk1)
   allocate (iwrk1(size(result)))
   call occurrences_(result, iwrk1)

   if (allocated(iwrk2)) deallocate (iwrk2)
   allocate (iwrk2(size(a)))
   call occurrences_(a, iwrk2)

   if (allocated(iwrk3)) deallocate (iwrk3)
   allocate (iwrk3(size(b)))
   call occurrences_(b, iwrk3)

   iwrk1=iwrk1-[iwrk2,iwrk3]

   kludge=pack(result//'',iwrk1.eq.0)
   result=unique(kludge,setOrder)

end function setxor_c
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK COMMENT --file issorted.3m_sets.man
NAME
   issorted(3f) - [M_sets] Report if A is sorted in ascending order or not.

SYNOPSIS

   issorted(A,setOrder)

DESCRIPTION

   Report if A is sorted in ascending order or not.  A 1 (true) is
   returned when the elements of A are listed in ascending order and 0
   (false) otherwise.

OPTIONS

    A     input array to test

RETURNS

    1 if input array A is sorted in ascending order, 0 otherwise

EXAMPLE

 sample program:

   program demo_issorted
   use M_sets, only: issorted
   character(len=*),parameter :: g='(*(g0,1x))'
   integer, allocatable      :: A(:)

      write(*,g) 'ISSORTED','Find the issorted elements of vector A.'
       A = [10, -10, 0, 1, 2, 3, 3, 2, 1, -10]
       write(*,g) 'A=', A
       write(*,g) issorted(A)
       A = [-10, 10, 100, 201]
       write(*,g) 'A=', A
       write(*,g) issorted(A)

   end program demo_issorted

Results:

 > ISSORTED Find the issorted elements of vector A.
 > A= 10 -10 0 1 2 3 3 2 1 -10
 > 0
 > A= -10 10 100 201
 > 1

AUTHORS
   John S. Urban, 2023-07-20

LICENSE
   CC0-1.0
$ENDBLOCK
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$PARCEL ISSORTED_TEMPLATE
function issorted_${KIND}(A) result(result)
! TF = issorted(A) returns the logical scalar 1 (true) when the elements of A are listed in ascending order and 0 (false) otherwise.
${TYPE}(kind=${KIND}), intent(in) :: A(:)
${TYPE}(kind=${KIND})             :: result
integer             :: i
result=1
do i=1,size(a)-1
   if(A(i).gt.A(i+1))then
      result=0
      exit
   endif
enddo
end function issorted_${KIND}
$ENDPARCEL ISSORTED_TEMPLATE
!-----------------------------------------------------------------------------------------------------------------------------------
function issorted_c(A) result(result)
! TF = issorted(A) returns the logical scalar 1 (true) when the elements of A are listed in ascending order and 0 (false) otherwise.
character(len=*), intent(in) :: A(:)
integer                      :: result
integer                      :: i
result=1
do i=1,size(a)-1
   if(A(i).gt.A(i+1))then
      result=0
      exit
   endif
enddo
end function issorted_c
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
elemental pure function lower(str) result (string)

$@(#) M_strings::lower(3f): Changes a string to lowercase

character(*), intent(in)    :: str
character(len(str))         :: string
integer                     :: i
integer,parameter           :: diff = iachar('A')-iachar('a')
   string = str
   do concurrent (i = 1:len_trim(str))                ! step thru each letter in the string in specified range
      select case (str(i:i))
      case ('A':'Z')
         string(i:i) = achar(iachar(str(i:i))-diff)   ! change letter to miniscule
      case default
      end select
   enddo

end function lower
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$PARCEL SPACE

$ENDPARCEL SPACE

$PARCEL PROCEDURES
$POST SPACE
$POST UNIQUE_TEMPLATE
$POST SPACE
$POST UNION_TEMPLATE
$POST SPACE
$POST INTERSECT_TEMPLATE
$POST SPACE
$POST SETDIFF_TEMPLATE
$POST SPACE
$POST ISMEMBER_TEMPLATE
$POST SPACE
$POST SETXOR_TEMPLATE
$POST SPACE
$POST ISSORTED_TEMPLATE
$ENDPARCEL PROCEDURES

$!>>> INTEGER
$set TYPE integer
$set KIND int8
$POST PROCEDURES
$set KIND int16
$POST PROCEDURES
$set KIND int32
$POST PROCEDURES
$set KIND int64
$POST PROCEDURES
$!>>> REAL
$set TYPE real
$set KIND real32
$POST PROCEDURES
$set KIND real64
$POST PROCEDURES

end module M_sets
