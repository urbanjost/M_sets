var tipuesearch = {"pages":[{"title":" M_sets ","text":"M_sets M_sets Name M_sets (3f) - functions reminiscent of Matlab set functions Description Set-theory operations compare the elements in two sets to find\ncommonalities, differences, and membership. M_set(3f) is a Fortran module comprising a small group of set-theory\nfunctions reminiscent of related Matlab procedures. M_set(3f) is intended to be built with and used by fpm(1) projects.\nIt requires M_orderpack(3f) as a dependency, which is of course\ntaken care of automatically via fpm(1). Currently the allowed sets are vectors of integer numbers or arrays\nof character variables. real numbers are allowed but “caveat emptor”,\nas comparing floats for equality has issues. You may have to condition\nthe float data by converting it to scaled integers or using intrinsics\nsuch as NEAREST(3f) to produce the desired results. Functions union(A,B,setOrder)     - Join two sets and remove duplicates of values unique(A,setOrder)      - Remove duplicates of values from a set intersect(A,B,setOrder) - Find the values common to both A and B setdiff(A,B,setOrder)   - Find the values in A that are not in B ismember(A,B,setOrder)  - Create a mask of A marking elements also in B setxor(A,B,setOrder)    - Find values of A and B not in both arrays issorted(A)             - Determine if array is already sorted bool(expr)              - returns 1 if expression is TRUE, else returns 0. The subsequent data may be produced sorted, or left in the order\n encountered. They (currently) select elements and do not return index locations. Since\n they already internally heavily depend on a multiplicity subroutine\n that might be unexpectedly easy to add, though. Example program demo_M_sets use M_sets , only : & & unique , intersect , union , setdiff , ismember , setxor , issorted , bool character ( len =* ), parameter :: all = '(*(g0,1x))' character ( len =* ), parameter :: nl = new_line ( 'A' ) integer , allocatable :: A (:) integer , allocatable :: B (:) integer , allocatable :: C (:) A = [ 10 , - 10 , 0 , 1 , 2 , 3 , 3 , 2 , 1 , - 10 ] ! print all , nl , & 'UNIQUE' , 'Find the unique elements of vector A.' , nl , & 'A=' , A , nl , & 'sorted=' , unique ( A ) , nl , & 'stable=' , unique ( A , setOrder = 'stable' ) A = [ 5 , 7 , 1 ] B = [ 3 , 1 , 1 ] ! print all , nl , & 'UNION' , 'Find the union of vectors A and B.' , nl , & 'A=' , A , nl , & 'B=' , B , nl , & 'sorted=' , union ( A , B , 'sorted' ) , nl , & 'stable=' , union ( A , B , 'stable' ) A = [ 7 , 1 , 7 , 7 , 4 ] B = [ 7 , 0 , 4 , 4 , 0 ] ! print all , nl , & 'INTERSECT' , 'Find the values common to both A and B.' , nl , & 'A=' , A , nl , & 'B=' , B , nl , & 'sorted=' , intersect ( A , B ) , nl , & 'stable=' , intersect ( A , B , setOrder = 'stable' ) A = [ 3 , 6 , 2 , 1 , 5 , 1 , 1 ] B = [ 2 , 4 , 6 ] ! print all , nl , & 'SETDIFF' , 'Find the values in A that are not in B.' , nl , & 'A=' , A , nl , & 'B=' , B , nl , & 'sorted=' , setdiff ( A , B , 'sorted' ) , nl , & 'stable=' , setdiff ( A , B , 'stable' ) A = [ 5 , 3 , 4 , 2 ] B = [ 2 , 4 , 4 , 4 , 6 , 8 ] ! print all , nl , & 'ISMEMBER' , 'Determine which elements of A are also in B.' , nl , & 'A=' , A , nl , & 'B=' , B , nl , & 'in A and B=' , ismember ( A , B ) A = [ 5 , 1 , 3 , 3 , 3 ] B = [ 4 , 1 , 2 ] ! print all , nl , & 'SETXOR' , & 'Find values of A and B not in their intersection.' , nl , & 'A=' , A , nl , & 'B=' , B , nl , & 'sorted=' , setxor ( A , B ) , nl , & 'stable=' , setxor ( A , B , 'stable' ) A = [ 1 , 2 , 3 , 4 , 5 ] B = [ 5 , 4 , 3 , 2 , 1 ] ! print all , nl , & 'ISSSORTED' , & 'confirm whether array is sorted in ascending order or not' , nl , & 'A=' , A , nl , & 'B=' , B , nl , & 'is A sorted?' , issorted ( A ) , nl , & 'is B sorted?' , issorted ( B ) end program demo_M_sets Results: >\n >  UNIQUE Find the unique elements of vector A.\n >  A= 10 -10 0 1 2 3 3 2 1 -10\n >  sorted= -10 0 1 2 3 10\n >  stable= 10 -10 0 1 2 3\n >\n >  UNION Find the union of vectors A and B.\n >  A= 5 7 1\n >  B= 3 1 1\n >  sorted= 1 3 5 7\n >  stable= 5 7 1 3\n >\n >  INTERSECT Find the values common to both A and B.\n >  A= 7 1 7 7 4\n >  B= 7 0 4 4 0\n >  sorted= 4 7\n >  stable= 7 4\n >\n >  SETDIFF Find the values in A that are not in B.\n >  A= 3 6 2 1 5 1 1\n >  B= 2 4 6\n >  sorted= 1 3 5\n >  stable= 3 1 5\n >\n >  ISMEMBER Determine which elements of A are also in B.\n >  A= 5 3 4 2\n >  B= 2 4 4 4 6 8\n >  in A and B= 0 0 1 1\n >\n >  SETXOR Find values of A and B not in their intersection.\n >  A= 5 1 3 3 3\n >  B= 4 1 2\n >  sorted= 2 3 4 5\n >  stable= 5 3 4 2\n >\n >  ISSSORTED confirm whether array is sorted in ascending order or not\n >  A= 1 2 3 4 5\n >  B= 5 4 3 2 1\n >  is A sorted? 1\n >  is B sorted? 0 Build and test with Download the github repository and build it with fpm ( as described at Fortran Package Manager ) git clone https://github.com/urbanjost/M_sets.git cd M_sets\n        fpm build or just list it as a dependency in your fpm.toml project file. [dependencies] M_sets = { git = \"https://github.com/urbanjost/M_sets.git\" } Documentation The documentation for each procedure is included in the source.\nThat documentation is also available as a flat text file, HTML\ndocuments, and man-pages. User A text manual contains all the procedure descriptions in a single flat ASCII\n     text file. routines are also described in HTML form using the format of man-pages. For easier searching and printing Javascript is used to combine\n     all those HTML descriptions of the man-pages into a single book . are the de-facto standard\n     method of providing procedure descriptions on Unix, GNU/Linux,\n     OpenBSD, Cygwin, WLS, and other ULS (Unix-Like Systems) Installation can vary depending on whether you are installing\n personal copies or as an administrator, but man-pages are well suited\n for any CLI user (Command-Line Interface): manpages.zip manpages.tgz - CHANGELOG provides a history of significant changes Developer ford(1) output . doxygen(1) output . github action status References See also M_orderpack M_random Developer Info Michel Olagnon","tags":"home","url":"index.html"},{"title":"bool – M_sets","text":"public interface bool Module Procedures private pure elemental function bool_expr(expr) NAME bool ( 3 f ) - [ M_sets :: LOGICAL ] returns One if expression is TRUE , else returns Zero . ( LICENSE : PD ) SYNOPSIS pure elemental integer function bool(expr)\n\n logical,intent(in) :: expr\n   or\n character(len=:)intent(in) :: expr\n   or\n integer|real|complex(in) :: expr DESCRIPTION bool(3f) returns an integer 1 given a true logical expression. OPTIONS expr  A logical expression. If any other intrinsic type a blank string is\n       TRUE as well as 0. 0.0, and (0.0,0.0). Non-zero numeric values\n       and non-blank or non-null strings are FALSE. RETURNS The result is a default INTEGER value of 1 if the expression is TRUE,\n   and a 0 otherwise. EXAMPLES Sample usage: program demo_bool use M_sets , only : bool implicit none write ( * , * ) ' is 10 < 20 ? ' , bool ( 10 < 20 ) write ( * , * ) ' elemental ' , bool ( [ 2 > 1 , 3 == 4 , 10 < 5 , 100 > 50 ] ) if ( sum ( bool ( [ 2 > 1 , 3 == 4 , 10 < 5 , 100 > 50 ] )) >= 2 ) then write ( * , * ) ' two or more are true ' endif end program demo_bool Results: > is 10 < 20 ? 1\n > elemental 1 0 0 1\n > two or more are true AUTHOR John S. Urban LICENSE CC0-1.0 Arguments Type Intent Optional Attributes Name logical, intent(in) :: expr Return Value integer private pure elemental function bool_int8(int) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: int Return Value integer private pure elemental function bool_int16(int) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: int Return Value integer private pure elemental function bool_int32(int) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: int Return Value integer private pure elemental function bool_int64(int) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: int Return Value integer private pure elemental function bool_float32(float) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: float Return Value integer private pure elemental function bool_float64(float) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: float Return Value integer private pure elemental function bool_complex32(val) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in) :: val Return Value integer private pure elemental function bool_complex64(val) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in) :: val Return Value integer private pure elemental function bool_char(string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value integer","tags":"","url":"interface/bool.html"},{"title":"intersect – M_sets","text":"public interface intersect Module Procedures private  function intersect_c(A, B, setOrder) result(answer) NAME intersect ( 3 f ) - [ M_sets ] Find the values common to both sets A and B SYNOPSIS intersect(A,B, setOrder) DESCRIPTION The values that occur at least once in each set are returned. That is, intersect(3f) returns the data common to both A and B, with\n no repetitions. OPTIONS A input array B input array setOrder May be \" sort \" or \" stable \" . If \" stable \" the values are returned in the order discovered . The default is \" sorted \" , which returns the data in ascending order . EXAMPLES sample program: program demo_intersect\n   use M_sets, only: unique, intersect, union, setdiff, ismember, setxor\n   character(len= ),parameter :: g=’( (g0,1x))’\n   integer, allocatable       :: A(:)\n   integer, allocatable       :: B(:) write(*,g) 'INTERSECT', 'Find the values common to both A and B.'\n   A=[7, 1, 7, 7, 4]\n   B=[7, 0, 4, 4, 0]\n   write(*,g) 'A=', A\n   write(*,g) 'B=', B\n   write(*,g) intersect(A, B)\n   write(*,g) intersect(A, B, setOrder='stable') end program demo_intersect Results: INTERSECT Find the values common to both A and B.\nA= 7 1 7 7 4\nB= 7 0 4 4 0\n4 7\n7 4 AUTHORS John S. Urban, 2023-07-20 LICENSE CC0-1.0 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: A (:) character(len=*), intent(in) :: B (:) character(len=*), intent(in), optional :: setOrder Return Value character(len=:), allocatable, (:)","tags":"","url":"interface/intersect.html"},{"title":"isequal – M_sets","text":"public interface isequal Module Procedures private  function isequal_c(A, B) result(answer) NAME isequal ( 3 f ) - [ M_sets ] Report if vector A is equal to vector B SYNOPSIS isequal(A,B,TOLERANCE)\n\n  character(len=:)intent(in) :: A,B\n    or\n  integer|real|complex(in) :: A,B\n  real,optional            :: TOLERANCE DESCRIPTION Report if A is equal to B . Equality is defined as the same element values in the same order . A 1 ( true ) is returned when the elements of A have a one - to - one correspondence to the elements of B with the same values in the same order . 0 ( false ) is returned otherwise . OPTIONS A input array to compare against B input array to compare to A TOLERANCE for numeric values consider the corresponding elements of A and B equal if they are equal within the specified tolerance . A , B and TOLERANCE are of the same type and kind . RETURNS 1 if input array A is to array B , 0 otherwise EXAMPLES sample program: program demo_isequal use M_sets , only : isequal character ( len =* ) , parameter :: g = ' (*(g0,1x)) ' integer , allocatable :: A ( : ) integer , allocatable :: B ( : ) write ( * , g ) ' isequal ' , ' Find if A is equal to B. ' A = [ 10 , - 10 , 0 , 1 , 2 , 3 , 3 , 2 , 1 , - 10 ] B = [ 10 , - 10 , 0 , 1 , 2 , 3 , 3 , 2 , 1 , 10 ] write ( * , g ) ' A= ' , A write ( * , g ) ' B= ' , B write ( * , g ) isequal ( A , B ) write ( * , g ) ' isequal ' , ' Find if A is equal to A. ' write ( * , g ) isequal ( A , A ) end program demo_isequal Results: isequal Find the isequal elements of vector A.\nA= 10 -10 0 1 2 3 3 2 1 -10\n0\nA= -10 10 100 201\n1 AUTHORS John S. Urban, 2023-07-20 LICENSE CC0-1.0 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: A (:) character(len=*), intent(in) :: B (:) Return Value integer","tags":"","url":"interface/isequal.html"},{"title":"ismember – M_sets","text":"public interface ismember Module Procedures private  function ismember_c(a, b) result(answer) NAME ismember ( 3 f ) - [ M_sets ] Create a mask of A marking elements also in B SYNOPSIS ismember(A,B) DESCRIPTION Identifies elements of the first set that are members of the second set\n as well. The returned array is a mask of the first array containing a 1\n (aka. “true”) where the data in A is found in B. Elsewhere, the array\n contains 0 (aka. “false”). OPTIONS A         input array\n B         input array of values to find in vector A. RETURNS A mask of array A with a 1 at locations where the value in that\n position in A is also a value that occurs in B, and with a 0 at\n locations where that value in A was not found in B. EXAMPLES sample program: program demo_ismember use M_sets , only : ismember character ( len =* ) , parameter :: g = ' (*(g0,1x)) ' integer , allocatable :: A ( : ) integer , allocatable :: B ( : ) write ( * , g ) ' ISMEMBER ' , ' Determine which elements of A are also in B. ' A = [ 5 , 3 , 4 , 2 ] B = [ 2 , 4 , 4 , 4 , 6 , 8 ] write ( * , g ) ' A= ' , A write ( * , g ) ' B= ' , B write ( * , g ) ismember ( A , B ) end program demo_ismember Results: ISMEMBER Determine which elements of A are also in B.\nA= 5 3 4 2\nB= 2 4 4 4 6 8\n0 0 1 1 AUTHORS John S. Urban, 2023-07-20 LICENSE CC0-1.0 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: a (:) character(len=*), intent(in) :: b (:) Return Value integer, allocatable, (:)","tags":"","url":"interface/ismember.html"},{"title":"issorted – M_sets","text":"public interface issorted Module Procedures private  function issorted_c(A) result(answer) NAME issorted ( 3 f ) - [ M_sets ] Report if A is sorted in ascending order or not . SYNOPSIS issorted(A)\n\n  character(len=:)intent(in) :: A\n    or\n  integer|real|complex(in) :: A DESCRIPTION Report if A is sorted in ascending order or not . A 1 ( true ) is returned when the elements of A are listed in ascending order and 0 ( false ) otherwise . OPTIONS A         input array to test RETURNS 1 if input array A is sorted in ascending order , 0 otherwise EXAMPLES sample program: program demo_issorted use M_sets , only : issorted character ( len =* ) , parameter :: g = ' (*(g0,1x)) ' integer , allocatable :: A ( : ) write ( * , g ) ' ISSORTED ' , ' Find the issorted elements of vector A. ' A = [ 10 , - 10 , 0 , 1 , 2 , 3 , 3 , 2 , 1 , - 10 ] write ( * , g ) ' A= ' , A write ( * , g ) issorted ( A ) A = [ - 10 , 10 , 100 , 201 ] write ( * , g ) ' A= ' , A write ( * , g ) issorted ( A ) end program demo_issorted Results: ISSORTED Find the issorted elements of vector A.\nA= 10 -10 0 1 2 3 3 2 1 -10\n0\nA= -10 10 100 201\n1 AUTHORS John S. Urban, 2023-07-20 LICENSE CC0-1.0 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: A (:) Return Value integer","tags":"","url":"interface/issorted.html"},{"title":"setdiff – M_sets","text":"public interface setdiff Module Procedures private  function setdiff_c(a, b, setOrder) result(answer) NAME setdiff ( 3 f ) - [ M_sets ] Find the values in A that are not in B SYNOPSIS setdiff(A,B, setOrder) DESCRIPTION setdiff(3f) returns the data in A that is not in B, with no repetitions. OPTIONS A input array B input array setOrder May be \" sort \" or \" stable \" . If \" stable \" the values are returned in the order discovered . The default is \" sorted \" , which returns the data in ascending order . EXAMPLES sample program: program demo_setdiff use M_sets , only : setdiff character ( len =* ) , parameter :: g = ' (*(g0,1x)) ' integer , allocatable :: A ( : ) integer , allocatable :: B ( : ) write ( * , g ) ' SETDIFF ' , ' Find the values in A that are not in B. ' A = [ 3 , 6 , 2 , 1 , 5 , 1 , 1 ] B = [ 2 , 4 , 6 ] write ( * , g ) ' A= ' , A write ( * , g ) ' B= ' , B write ( * , g ) setdiff ( A , B ) write ( * , g ) setdiff ( [ 4 , 1 , 3 , 2 , 5 ], [ 2 , 1 ], ' sorted ' ) write ( * , g ) setdiff ( [ 4 , 1 , 3 , 2 , 5 ], [ 2 , 1 ], ' stable ' ) end program demo_setdiff Results: SETDIFF Find the values in A that are not in B.\nA= 3 6 2 1 5 1 1\nB= 2 4 6\n1 3 5\n3 4 5\n4 3 5 AUTHORS John S. Urban, 2023-07-20 LICENSE CC0-1.0 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: a (:) character(len=*), intent(in) :: b (:) character(len=*), intent(in), optional :: setOrder Return Value character(len=:), allocatable, (:)","tags":"","url":"interface/setdiff.html"},{"title":"setxor – M_sets","text":"public interface setxor Module Procedures private  function setxor_c(a, b, setOrder) result(answer) NAME setxor ( 3 f ) - [ M_sets ] Find values of A and B not in both arrays SYNOPSIS setxor(A,B, setOrder) DESCRIPTION setxfor(3f) returns the exclusive OR of two arrays. That is, it returns\n the data of A and B that are not in their intersection (the symmetric\n difference), with no repetitions. Another way of defining the result is that setxor(3f) returns the data\n that occurs in A or B, but not both. OPTIONS A input array B input array setOrder May be \" sort \" or \" stable \" . If \" stable \" the values are returned in the order discovered . The default is \" sorted \" , which returns the data in ascending order . EXAMPLES sample program: program demo_setxor use M_sets , only : setxor character ( len =* ) , parameter :: g = ' (*(g0,1x)) ' integer , allocatable :: A ( : ) integer , allocatable :: B ( : ) write ( * , g ) ' SETXOR ' , ' Find values of A and B not in their intersection. ' A = [ 5 , 1 , 3 , 3 , 3 ] B = [ 4 , 1 , 2 ] write ( * , g ) ' A= ' , A write ( * , g ) ' B= ' , B write ( * , g ) setxor ( A , B ) write ( * , g ) setxor ( A , B , ' stable ' ) end program demo_setxor Results: SETXOR Find values of A and B not in their intersection.\nA= 5 1 3 3 3\nB= 4 1 2\n2 3 4 5\n5 3 4 2 AUTHORS John S. Urban, 2023-07-20 LICENSE CC0-1.0 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: a (:) character(len=*), intent(in) :: b (:) character(len=*), intent(in), optional :: setOrder Return Value character(len=:), allocatable, (:)","tags":"","url":"interface/setxor.html"},{"title":"union – M_sets","text":"public interface union Module Procedures private  function union_c(A, B, setOrder) result(answer) NAME union ( 3 f ) - [ M_sets ] Join two sets and removes duplicates of values SYNOPSIS union(A,B, setOrder) DESCRIPTION The two sets are combined and repetitions are removed. OPTIONS A input array B input array setOrder May be \" sort \" or \" stable \" . If \" stable \" the values are returned in the order discovered . The default is \" sorted \" , which returns the data in ascending order . EXAMPLES sample program: program demo_union use M_sets , only : union character ( len =* ) , parameter :: g = ' (*(g0,1x)) ' integer , allocatable :: A ( : ) integer , allocatable :: B ( : ) write ( * , g ) ' UNION ' , ' Find the union of vectors A and B. ' A = [ 5 , 7 , 1 ] B = [ 3 , 1 , 1 ] write ( * , g ) ' A= ' , A write ( * , g ) ' B= ' , B write ( * , g ) union ( A , B ) A = [ 5 , 5 , 3 ] B = [ 1 , 2 , 5 ] write ( * , g ) ' A= ' , A write ( * , g ) ' B= ' , B write ( * , g ) union ( A , B , ' sorted ' ) write ( * , g ) union ( A , B , ' stable ' ) end program demo_union ```\n Results: UNION Find the union of vectors A and B.\nA= 5 7 1\nB= 3 1 1\n1 3 5 7\nA= 5 5 3\nB= 1 2 5\n1 2 3 5\n5 3 1 2 AUTHORS John S. Urban, 2023-07-20 LICENSE CC0-1.0 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: A (:) character(len=*), intent(in) :: B (:) character(len=*), intent(in), optional :: setOrder Return Value character(len=:), allocatable, (:)","tags":"","url":"interface/union.html"},{"title":"unique – M_sets","text":"public interface unique Module Procedures private  function unique_c(A, setOrder) result(answer) NAME unique ( 3 f ) - [ M_sets ] return unique values in array A SYNOPSIS unique(A,setOrder) DESCRIPTION unique(3) returns the unique values found in an array. That is, it\n eliminates all but one occurrence of each value. The result is in sorted order by default, but may be returned in the\n order found. OPTIONS A input array to extract unique values from setOrder May be \" sort \" or \" stable \" . If \" stable \" the values are returned in the order discovered . The default is \" sorted \" , which returns the data in ascending order . RETURNS All the values that occur in the input occur in the output\n just once. All duplicates are removed. EXAMPLES sample program: program demo_unique use M_sets , only : unique character ( len =* ) , parameter :: g = ' (*(g0,1x)) ' integer , allocatable :: A ( : ) write ( * , g ) ' UNIQUE ' , ' Find the unique elements of vector A. ' A = [ 10 , - 10 , 0 , 1 , 2 , 3 , 3 , 2 , 1 , - 10 ] write ( * , g ) ' A= ' , A write ( * , g ) unique ( A ) write ( * , g ) unique ( A , setOrder = ' stable ' ) end program demo_unique Results: UNIQUE Find the unique elements of vector A.\nA= 10 -10 0 1 2 3 3 2 1 -10\n-10 0 1 2 3 10\n10 -10 0 1 2 3 AUTHORS John S. Urban, 2023-07-20 LICENSE CC0-1.0 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: A (:) character(len=*), intent(in), optional :: setOrder Return Value character(len=:), allocatable, (:)","tags":"","url":"interface/unique.html"},{"title":"test_bool – M_sets","text":"subroutine test_bool() Uses M_sets Arguments None Source Code subroutine test_bool use M_sets , only : bool call unit_test_start ( 'bool' , 'convert logical to integer. 1 is true, 0 is false.' ) call unit_test ( 'bool' , bool ( 10 < 20 ). eq . 1 , 'true expression' , bool ( 10 < 20 )) call unit_test ( 'bool' , bool ( 10 > 20 ). eq . 0 , 'false expression' , bool ( 10 > 20 )) call unit_test ( 'bool' , all ( bool ([ 2 > 1 , 3 == 4 , 10 < 5 , 100 > 50 ]). eq .[ 1 , 0 , 0 , 1 ]), 'elemental' ) A = [ 10 , - 10 , 0 , 1 , 2 , 3 , 3 , 2 , 1 , - 10 ] call unit_test ( 'bool' , all ( bool ( A ). eq .[ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]), 'integers' , str ( bool ( A ))) strA = [ \"0\" , \"0\" , \"1\" , \"2\" , \"3\" , \"3\" , \"2\" , \"1\" ] call unit_test ( 'bool' , all ( bool ( strA ). eq .[ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]), 'strings' , str ( bool ( strA ))) fltA = [ 0.5469 , 0.5469 , 1.5469 , 2.5469 , 3.5469 , 3.5469 , 2.5469 , 1.5469 ] call unit_test ( 'bool' , all ( bool ( fltA ). eq .[ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]), 'real' , str ( bool ( fltA ))) end subroutine test_bool","tags":"","url":"proc/test_bool.html"},{"title":"test_intersect – M_sets","text":"subroutine test_intersect() Arguments None Source Code subroutine test_intersect call unit_test_start ( 'intersect' , 'find the values common to both A and B' ) ! start tests A = [ 7 , 1 , 7 , 7 , 4 ] B = [ 7 , 0 , 4 , 4 , 0 ] C = intersect ( A , B ) expected = [ 4 , 7 ] call unit_test ( 'intersect' , size ( C ). eq . size ( expected ), 'sorted size' , 'expected' , size ( expected ), 'got' , size ( c )) if ( size ( C ). eq . size ( expected )) then call unit_test ( 'intersect' , all ( C . eq . expected ), 'sorted, expected' , str ( expected ), 'got' , str ( C )) endif C = intersect ( A , B , 'stable' ) expected = [ 7 , 4 ] call unit_test ( 'intersect' , size ( C ). eq . size ( expected ), 'stable size' , 'expected' , size ( expected ), 'got' , size ( c )) if ( size ( C ). eq . size ( expected )) then call unit_test ( 'intersect' , all ( C . eq . expected ), 'stable, expected' , str ( expected ), 'got' , str ( C )) endif strA = [ \"7\" , \"1\" , \"7\" , \"7\" , \"4\" ] strB = [ \"7\" , \"0\" , \"4\" , \"4\" , \"0\" ] strC = intersect ( strA , strB ) strexpected = [ \"4\" , \"7\" ] call unit_test ( 'intersect' , size ( strC ). eq . size ( strexpected ), 'sorted size' ,& 'expected' , size ( strexpected ), 'got' , size ( strc ), 'output=' , str ( strC )) if ( size ( C ). eq . size ( strexpected )) then call unit_test ( 'intersect' , all ( strC . eq . strexpected ), 'sorted, expected' , str ( strexpected ), 'got' , str ( strC )) endif strC = intersect ( strA , strB , 'stable' ) strexpected = [ \"7\" , \"4\" ] call unit_test ( 'intersect' , size ( strC ). eq . size ( strexpected ), 'stable size' ,& 'expected' , size ( strexpected ), 'got' , size ( strc ), 'output=' , str ( strc )) if ( size ( C ). eq . size ( strexpected )) then call unit_test ( 'intersect' , all ( strC . eq . strexpected ), 'stable, expected' , str ( strexpected ), 'got' , str ( strC )) endif fltA = [ 7.777 , 1.111 , 7.777 , 7.777 , 4.444 ] fltB = [ 7.777 , 0.000 , 4.444 , 4.444 , 0.000 ] fltC = intersect ( fltA , fltB ) fltexpected = [ 4.444 , 7.777 ] call unit_test ( 'intersect' , size ( fltC ). eq . size ( fltexpected ), 'sorted size' ,& & 'expected' , size ( fltexpected ), 'got' , size ( fltc )) if ( size ( fltC ). eq . size ( fltexpected )) then call unit_test ( 'intersect' , all ( fltC . eq . fltexpected ), 'sorted, expected' , str ( fltexpected ), 'got' , str ( fltC )) endif fltC = intersect ( fltA , fltB , 'stable' ) fltexpected = [ 7.777 , 4.444 ] call unit_test ( 'intersect' , size ( fltC ). eq . size ( fltexpected ), 'stable size' ,& & 'expected' , size ( fltexpected ), 'got' , size ( fltc )) if ( size ( fltC ). eq . size ( fltexpected )) then call unit_test ( 'intersect' , all ( fltC . eq . fltexpected ), 'stable, expected' , str ( fltexpected ), 'got' , str ( fltC )) endif call unit_test_done ( 'intersect' , msg = 'test completed' ) end subroutine test_intersect","tags":"","url":"proc/test_intersect.html"},{"title":"test_isequal – M_sets","text":"subroutine test_isequal() Uses M_sets Arguments None Source Code subroutine test_isequal use M_sets , only : isequal call unit_test_start ( 'isequal' , 'Find if vector A and B are identical.' ) A = [ 10 , - 10 , 0 , 1 , 2 , 3 , 3 , 2 , 1 , - 10 ] B = [ 10 , - 10 , 0 , 1 , 2 , 3 , - 3 , 2 , 1 , - 10 ] call unit_test ( 'isequal' , isequal ( A , B ). eq . 0 , 'integer A,B expected 0 got' , isequal ( A , B )) call unit_test ( 'isequal' , isequal ( A , A ). eq . 1 , 'integer A,A expected 1 got' , isequal ( A , A )) strA = [ \"0\" , \"0\" , \"1\" , \"2\" , \"3\" , \"3\" , \"2\" , \"1\" ] strB = [ \"0\" , \"O\" , \"1\" , \"2\" , \"3\" , \"3\" , \"2\" , \"1\" ] call unit_test ( 'isequal' , isequal ( strA , strB ). eq . 0 , 'string A,B expected 0 got' , isequal ( strA , strB )) call unit_test ( 'isequal' , isequal ( strA , strA ). eq . 1 , 'string A,A expected 1 got' , isequal ( strA , strA )) fltA = [ 0.5469 , 0.5469 , 1.5469 , 2.5469 , 3.5469 , 3.5469 , 2.5469 , 1.5469 ] fltB = [ 0.5469 , 0.5469 , 1.5469 , 2.5469 , 3.5469 , 3.4569 , 2.5469 , 1.5469 ] call unit_test ( 'isequal' , isequal ( fltA , fltB ). eq . 0 , 'flting A,B expected 0 got' , isequal ( fltA , fltB )) call unit_test ( 'isequal' , isequal ( fltA , fltA ). eq . 1 , 'flting A,A expected 1 got' , isequal ( fltA , fltA )) end subroutine test_isequal","tags":"","url":"proc/test_isequal.html"},{"title":"test_ismember – M_sets","text":"subroutine test_ismember() Arguments None Source Code subroutine test_ismember call unit_test_start ( 'ismember' , 'report which values in A are also in B' ) ! start tests ! ! Create two vectors with values in common. A = [ 5 , 3 , 4 , 2 ] B = [ 2 , 4 , 4 , 4 , 6 , 8 ] C = ismember ( A , B ) expected = [ 0 , 0 , 1 , 1 ] call unit_test ( 'ismember' , size ( C ). eq . size ( expected ), 'sorted size' ) if ( size ( C ). eq . size ( expected )) then call unit_test ( 'ismember' , all ( C . eq . expected ), 'sorted, expected' , str ( expected ), 'got' , str ( C )) endif strA = [ \"5\" , \"3\" , \"4\" , \"2\" ] strB = [ \"2\" , \"4\" , \"4\" , \"4\" , \"6\" , \"8\" ] C = ismember ( strA , strB ) expected = [ 0 , 0 , 1 , 1 ] call unit_test ( 'ismember' , size ( C ). eq . size ( expected ), 'sorted size' ) if ( size ( C ). eq . size ( expected )) then call unit_test ( 'ismember' , all ( C . eq . expected ), 'sorted, expected' , str ( expected ), 'got' , str ( C )) endif fltA = [ 5.5421 , 3.5421 , 4.5421 , 2.5421 ] fltB = [ 2.5421 , 4.5421 , 4.5421 , 4.5421 , 6.5421 , 8.5421 ] C = ismember ( fltA , fltB ) expected = [ 0 , 0 , 1 , 1 ] call unit_test ( 'ismember' , size ( C ). eq . size ( expected ), 'sorted size' ) if ( size ( C ). eq . size ( expected )) then call unit_test ( 'ismember' , all ( C . eq . expected ), 'sorted, expected' , str ( expected ), 'got' , str ( C )) endif call unit_test_done ( 'ismember' , msg = 'test completed' ) end subroutine test_ismember","tags":"","url":"proc/test_ismember.html"},{"title":"test_issorted – M_sets","text":"subroutine test_issorted() Uses M_sets Arguments None Source Code subroutine test_issorted use M_sets , only : issorted call unit_test_start ( 'issorted' , 'Find the issorted elements of vector A.' ) A = [ 10 , - 10 , 0 , 1 , 2 , 3 , 3 , 2 , 1 , - 10 ] call unit_test ( 'issorted' , issorted ( A ). eq . 0 , 'sorted, expected 0 got' , issorted ( A )) A = [ - 10 , 10 , 100 , 201 ] call unit_test ( 'issorted' , issorted ( A ). eq . 1 , 'sorted, expected 1 got' , issorted ( A )) strA = [ \"0\" , \"0\" , \"1\" , \"2\" , \"3\" , \"3\" , \"2\" , \"1\" ] call unit_test ( 'issorted' , issorted ( strA ). eq . 0 , 'sorted, expected 0 got' , issorted ( strA )) strA = [ \"10\" , \"20\" , \"30\" ] call unit_test ( 'issorted' , issorted ( strA ). eq . 1 , 'sorted, expected 1 got' , issorted ( strA )) fltA = [ 0.5469 , 0.5469 , 1.5469 , 2.5469 , 3.5469 , 3.5469 , 2.5469 , 1.5469 ] call unit_test ( 'issorted' , issorted ( fltA ). eq . 0 , 'sorted, expected 0 got' , issorted ( fltA )) fltA = [ 1 0.5469 , 2 0.5469 , 3 0.5469 ] call unit_test ( 'issorted' , issorted ( fltA ). eq . 1 , 'sorted, expected 1 got' , issorted ( fltA )) end subroutine test_issorted","tags":"","url":"proc/test_issorted.html"},{"title":"test_setdiff – M_sets","text":"subroutine test_setdiff() Arguments None Source Code subroutine test_setdiff call unit_test_start ( 'setdiff' , 'find the values in A that are not in B' ) ! start tests A = [ 3 , 6 , 2 , 1 , 5 , 1 , 1 ] B = [ 2 , 4 , 6 ] C = setdiff ( A , B ) expected = [ 1 , 3 , 5 ] call unit_test ( 'setdiff' , size ( C ). eq . size ( expected ), 'sorted size' ) if ( size ( C ). eq . size ( expected )) then call unit_test ( 'setdiff' , all ( C . eq . expected ), 'sorted, expected' , str ( expected ), 'got' , str ( C )) endif A = [ 4 , 1 , 3 , 2 , 5 ] B = [ 2 , 1 ] C = setdiff ( A , B , 'sorted' ) expected = [ 3 , 4 , 5 ] call unit_test ( 'setdiff' , size ( C ). eq . size ( expected ), 'stable size' ) if ( size ( C ). eq . size ( expected )) then call unit_test ( 'setdiff' , all ( C . eq . expected ), 'stable, expected' , str ( expected ), 'got' , str ( C )) endif C = setdiff ( A , B , 'stable' ) expected = [ 4 , 3 , 5 ] call unit_test ( 'setdiff' , size ( C ). eq . size ( expected ), 'stable size' ) if ( size ( C ). eq . size ( expected )) then call unit_test ( 'setdiff' , all ( C . eq . expected ), 'stable, expected' , str ( expected ), 'got' , str ( C )) endif strA = [ '3' , '6' , '2' , '1' , '5' , '1' , '1' ] strB = [ '2' , '4' , '6' ] strC = setdiff ( strA , strB ) strexpected = [ '1' , '3' , '5' ] call unit_test ( 'setdiff' , size ( strC ). eq . size ( strexpected ), 'sorted size' ) if ( size ( C ). eq . size ( strexpected )) then call unit_test ( 'setdiff' , all ( strC . eq . strexpected ), 'sorted, expected' , str ( strexpected ), 'got' , str ( strC )) endif strA = [ '4' , '1' , '3' , '2' , '5' ] strB = [ '2' , '1' ] strC = setdiff ( strA , strB , 'sorted' ) strexpected = [ '3' , '4' , '5' ] call unit_test ( 'setdiff' , size ( strC ). eq . size ( strexpected ), 'stable size' ) if ( size ( C ). eq . size ( strexpected )) then call unit_test ( 'setdiff' , all ( strC . eq . strexpected ), 'stable, expected' , str ( strexpected ), 'got' , str ( strC )) endif strC = setdiff ( strA , strB , 'stable' ) strexpected = [ '4' , '3' , '5' ] call unit_test ( 'setdiff' , size ( strC ). eq . size ( strexpected ), 'stable size' ) if ( size ( C ). eq . size ( strexpected )) then call unit_test ( 'setdiff' , all ( strC . eq . strexpected ), 'stable, expected' , str ( strexpected ), 'got' , str ( strC )) endif fltA = [ 3.456 , 6.54321 , 2.01 , 1.008 , 5.35 , 1.008 , 1.008 ] fltB = [ 2.01 , 4.6853 , 6.54321 ] fltC = setdiff ( fltA , fltB ) fltexpected = [ 1.008 , 3.456 , 5.35 ] call unit_test ( 'setdiff' , size ( fltC ). eq . size ( strexpected ), 'sorted size' ) if ( size ( fltC ). eq . size ( strexpected )) then call unit_test ( 'setdiff' , all ( fltC . eq . fltexpected ), 'sorted, expected' , str ( fltexpected ), 'got' , str ( fltC )) endif fltA = [ 4.6853 , 1.008 , 3.456 , 2.01 , 5.35 ] fltB = [ 2.01 , 1.008 ] fltC = setdiff ( fltA , fltB , 'sorted' ) fltexpected = [ 3.456 , 4.6853 , 5.35 ] call unit_test ( 'setdiff' , size ( fltC ). eq . size ( fltexpected ), 'stable size' ) if ( size ( fltC ). eq . size ( fltexpected )) then call unit_test ( 'setdiff' , all ( fltC . eq . fltexpected ), 'stable, expected' , str ( fltexpected ), 'got' , str ( fltC )) endif fltC = setdiff ( fltA , fltB , 'stable' ) fltexpected = [ 4.6853 , 3.456 , 5.35 ] call unit_test ( 'setdiff' , size ( fltC ). eq . size ( fltexpected ), 'stable size' ) if ( size ( fltC ). eq . size ( fltexpected )) then call unit_test ( 'setdiff' , all ( fltC . eq . fltexpected ), 'stable, expected' , str ( fltexpected ), 'got' , str ( fltC )) endif call unit_test_done ( 'setdiff' , msg = 'test completed' ) end subroutine test_setdiff","tags":"","url":"proc/test_setdiff.html"},{"title":"test_setxor – M_sets","text":"subroutine test_setxor() Arguments None Source Code subroutine test_setxor call unit_test_start ( 'setxor' , 'find values two vectors do not share' ) ! start tests A = [ 5 , 1 , 3 , 3 , 3 ] B = [ 4 , 1 , 2 ] C = setxor ( A , B ) expected = [ 2 , 3 , 4 , 5 ] call unit_test ( 'setxor' , size ( C ). eq . size ( expected ), 'sorted size' ) if ( size ( C ). eq . size ( expected )) then call unit_test ( 'setxor' , all ( C . eq . expected ), 'sorted, expected' , str ( expected ), 'got' , str ( C )) endif C = setxor ( A , B , 'stable' ) expected = [ 5 , 3 , 4 , 2 ] call unit_test ( 'setxor' , size ( C ). eq . size ( expected ), 'stable size' ) if ( size ( C ). eq . size ( expected )) then call unit_test ( 'setxor' , all ( C . eq . expected ), 'stable, expected' , str ( expected ), 'got' , str ( C )) endif strA = [ \"5\" , \"1\" , \"3\" , \"3\" , \"3\" ] strB = [ \"4\" , \"1\" , \"2\" ] strC = setxor ( strA , strB ) strexpected = [ \"2\" , \"3\" , \"4\" , \"5\" ] call unit_test ( 'setxor' , size ( strC ). eq . size ( strexpected ), 'sorted size' ) if ( size ( strC ). eq . size ( strexpected )) then call unit_test ( 'setxor' , all ( strC . eq . strexpected ), 'sorted, expected' , str ( strexpected ), 'got' , str ( strC )) endif strC = setxor ( strA , strB , 'stable' ) strexpected = [ \"5\" , \"3\" , \"4\" , \"2\" ] call unit_test ( 'setxor' , size ( strC ). eq . size ( strexpected ), 'sorted size' ) if ( size ( strC ). eq . size ( strexpected )) then call unit_test ( 'setxor' , all ( strC . eq . strexpected ), 'stable, expected' , str ( strexpected ), 'got' , str ( strC )) endif fltA = [ 5.4321 , 1.11111 , 3.55555 , 3.55555 , 3.55555 ] fltB = [ 4.9087 , 1.11111 , 2.0000 ] fltC = setxor ( fltA , fltB ) fltexpected = [ 2.0000 , 3.55555 , 4.9087 , 5.4321 ] call unit_test ( 'setxor' , size ( fltC ). eq . size ( fltexpected ), 'sorted size' ) if ( size ( fltC ). eq . size ( fltexpected )) then call unit_test ( 'setxor' , all ( fltC . eq . fltexpected ), 'sorted, expected' , str ( fltexpected ), 'got' , str ( fltC )) endif fltC = setxor ( fltA , fltB , 'stable' ) fltexpected = [ 5.4321 , 3.55555 , 4.9087 , 2.0000 ] call unit_test ( 'setxor' , size ( fltC ). eq . size ( fltexpected ), 'sorted size' ) if ( size ( fltC ). eq . size ( fltexpected )) then call unit_test ( 'setxor' , all ( fltC . eq . fltexpected ), 'stable, expected' , str ( fltexpected ), 'got' , str ( fltC )) endif call unit_test_done ( 'setxor' , msg = 'test completed' ) end subroutine test_setxor","tags":"","url":"proc/test_setxor.html"},{"title":"test_union – M_sets","text":"subroutine test_union() Arguments None Source Code subroutine test_union call unit_test_start ( 'union' , 'find the unique elements of vactors A and B' ) ! start tests A = [ 5 , 7 , 1 ] B = [ 3 , 1 , 1 ] C = union ( A , B ) expected = [ 1 , 3 , 5 , 7 ] call unit_test ( 'union' , size ( C ). eq . size ( expected ), 'sorted size' ) if ( size ( C ). eq . size ( expected )) then call unit_test ( 'union' , all ( C . eq . expected ), 'default, expected' , str ( expected ), 'got' , str ( C )) endif A = [ 5 , 5 , 3 ] B = [ 1 , 2 , 5 ] C = union ( A , B , 'sorted' ) expected = [ 1 , 2 , 3 , 5 ] call unit_test ( 'union' , size ( C ). eq . size ( expected ), 'sorted size' ) if ( size ( C ). eq . size ( expected )) then call unit_test ( 'union' , all ( C . eq . expected ), 'sorted, expected' , str ( expected ), 'got' , str ( C )) endif C = union ( A , B , 'stable' ) expected = [ 5 , 3 , 1 , 2 ] call unit_test ( 'union' , size ( C ). eq . size ( expected ), 'stable size' ) if ( size ( C ). eq . size ( expected )) then call unit_test ( 'union' , all ( C . eq . expected ), 'stable, expected' , str ( expected ), 'got' , str ( C )) endif strA = [ \"5\" , \"7\" , \"1\" ] strB = [ \"3\" , \"1\" , \"1\" ] strC = union ( strA , strB ) strexpected = [ \"1\" , \"3\" , \"5\" , \"7\" ] call unit_test ( 'union' , size ( strC ). eq . size ( strexpected ), 'default size' , 'expected' , size ( strexpected ), 'got' , size ( strC )) if ( size ( strC ). eq . size ( strexpected )) then call unit_test ( 'union' , all ( strC . eq . strexpected ), 'default, expected' , str ( strexpected ), 'got' , str ( strC )) endif strA = [ \"5\" , \"5\" , \"3\" ] strB = [ \"1\" , \"2\" , \"5\" ] strC = union ( strA , strB , 'sorted' ) strexpected = [ \"1\" , \"2\" , \"3\" , \"5\" ] call unit_test ( 'union' , size ( strC ). eq . size ( strexpected ), 'sorted size' , 'expected' , size ( strexpected ), 'got' , size ( strC )) if ( size ( strC ). eq . size ( strexpected )) then call unit_test ( 'union' , all ( strC . eq . strexpected ), 'sorted, expected' , str ( strexpected ), 'got' , str ( strC )) endif strC = union ( strA , strB , 'stable' ) strexpected = [ \"5\" , \"3\" , \"1\" , \"2\" ] call unit_test ( 'union' , size ( strC ). eq . size ( strexpected ), 'stable size' , 'expected' , size ( strexpected ), 'got' , size ( strC )) if ( size ( strC ). eq . size ( strexpected )) then call unit_test ( 'union' , all ( strC . eq . strexpected ), 'stable, expected' , str ( strexpected ), 'got' , str ( strC )) endif fltA = [ 5.5 , 7.0 , 1.2345 ] fltB = [ 3.333 , 1.2345 , 1.2345 ] fltC = union ( fltA , fltB ) fltexpected = [ 1.2345 , 3.333 , 5.5 , 7.0 ] call unit_test ( 'union' , size ( fltC ). eq . size ( fltexpected ), 'sorted size' ) if ( size ( fltC ). eq . size ( fltexpected )) then call unit_test ( 'union' , all ( fltC . eq . fltexpected ), 'default, expected' , str ( fltexpected ), 'got' , str ( fltC )) endif fltA = [ 5.5 , 5.5 , 3.333 ] fltB = [ 1.234 , 2.0 , 5.5 ] fltC = union ( fltA , fltB , 'sorted' ) fltexpected = [ 1.234 , 2.0 , 3.333 , 5.5 ] call unit_test ( 'union' , size ( fltC ). eq . size ( fltexpected ), 'sorted size' ) if ( size ( fltC ). eq . size ( fltexpected )) then call unit_test ( 'union' , all ( fltC . eq . fltexpected ), 'sorted, expected' , str ( fltexpected ), 'got' , str ( fltC )) endif fltC = union ( fltA , fltB , 'stable' ) fltexpected = [ 5.5 , 3.333 , 1.234 , 2.0 ] call unit_test ( 'union' , size ( fltC ). eq . size ( fltexpected ), 'stable size' ) if ( size ( fltC ). eq . size ( fltexpected )) then call unit_test ( 'union' , all ( fltC . eq . fltexpected ), 'stable, expected' , str ( fltexpected ), 'got' , str ( fltC )) endif call unit_test_done ( 'union' , msg = 'test completed' ) end subroutine test_union","tags":"","url":"proc/test_union.html"},{"title":"test_unique – M_sets","text":"subroutine test_unique() Arguments None Source Code subroutine test_unique call unit_test_start ( 'unique' , 'find the unique elements of vactor A' ) ! start tests A = [ 10 , - 10 , 0 , 1 , 2 , 3 , 3 , 2 , 1 , - 10 ] strA = [ 'ab' , 'AB' , 'zz' , 'mq' , 'qm' , 'mq' , 'Za' , 'zz' , 'bb' , 'qm' ] C = unique ( A ) expected = [ - 10 , 0 , 1 , 2 , 3 , 10 ] call unit_test ( 'unique' , size ( C ). eq . size ( expected ), 'sorted size' ) if ( size ( C ). eq . size ( expected )) then call unit_test ( 'unique' , all ( C . eq . expected ), 'sorted, expected' , str ( expected ), 'got' , str ( C )) endif C = unique ( A , setOrder = 'stable' ) expected = [ 10 , - 10 , 0 , 1 , 2 , 3 ] call unit_test ( 'unique' , size ( C ). eq . size ( expected ), 'stable size' ) if ( size ( C ). eq . size ( expected )) then call unit_test ( 'unique' , all ( C . eq . expected ), 'stable, expected' , str ( expected ), 'got' , str ( C )) endif strC = unique ( strA , setorder = 'stable' ) strexpected = [ 'ab' , 'AB' , 'zz' , 'mq' , 'qm' , 'Za' , 'bb' ] call unit_test ( 'unique' , size ( strC ). eq . size ( strexpected ), 'sorted size' ) if ( size ( strC ). eq . size ( strexpected )) then call unit_test ( 'unique' , all ( strC . eq . strexpected ), 'stable, expected' , str ( strexpected ), 'got' , str ( strC )) endif strC = unique ( strA , setorder = 'sorted' ) strexpected = [ \"AB\" , \"Za\" , \"ab\" , \"bb\" , \"mq\" , \"qm\" , \"zz\" ] call unit_test ( 'unique' , size ( strC ). eq . size ( strexpected ), 'sorted size' ) if ( size ( strC ). eq . size ( strexpected )) then call unit_test ( 'unique' , all ( strC . eq . strexpected ), 'sorted, expected' , str ( strexpected ), 'got' , str ( strC )) endif fltA = [ 1 0.1 , - 1 0.0 , 0.0 , 1.11 , 2.22 , 3.33 , 3.33 , 2.22 , 1.11 , - 1 0.0 ] fltC = unique ( fltA ) fltexpected = [ - 1 0.0 , 0.0 , 1.11 , 2.22 , 3.33 , 1 0.1 ] call unit_test ( 'unique' , size ( fltC ). eq . size ( fltexpected ), 'sorted size' ) if ( size ( fltC ). eq . size ( fltexpected )) then call unit_test ( 'unique' , all ( fltC . eq . fltexpected ), 'sorted, expected' , str ( fltexpected ), 'got' , str ( fltC )) endif fltC = unique ( fltA , setOrder = 'stable' ) fltexpected = [ 1 0.1 , - 1 0.0 , 0.0 , 1.11 , 2.22 , 3.33 ] call unit_test ( 'unique' , size ( fltC ). eq . size ( fltexpected ), 'stable size' ) if ( size ( fltC ). eq . size ( fltexpected )) then call unit_test ( 'unique' , all ( fltC . eq . fltexpected ), 'stable, expected' , str ( fltexpected ), 'got' , str ( fltC )) endif call unit_test_done ( 'unique' , msg = 'test completed' ) end subroutine test_unique","tags":"","url":"proc/test_unique.html"},{"title":"M_sets – M_sets","text":"NAME M_sets(3f) - [M_sets::INTRO] functions reminiscent of Matlab set\nfunctions SYNOPSIS Proc edure names and syntax : use M_sets , only : & & union , unique , intersect , setdiff , ismember , setxor use M_sets , only : & & issorted , isequal , bool DESCRIPTION Set operations compare the elements in two sets to find commonalities\n or differences. This includes Unions, Intersections, and Membership. M_set(3f) is a Fortran module comprising a small subset of set theory\n functions reminiscent of Matlab functions. The functions currently support vectors of integer, default character,\n and default real and doubleprecision type. float numbers (both kind=real32 and kind=real64) are allowed but “caveat\n emptor”, as comparing floats for equality has issues. You may have to\n condition the float data by converting it to scaled integers or using\n intrinsics such as NEAREST(3f) to produce the desired results. M_set(3f) primarily uses simple calls to the M_orderpack(3f) module to\n provide the functionality. The functions are not otherwise tuned for\n performance and make loose use of memory allocation but are sufficient\n for most uses, simple to use, and familiar to a large base of users. ## Functions\n  + union(A,B,setOrder)     - Join two sets and remove duplicates of values\n  + unique(A,setOrder)      - Remove duplicates of values from a set\n  + intersect(A,B,setOrder) - Find the values common to both A and B\n  + setdiff(A,B,setOrder)   - Find the values in A that are not in B\n  + ismember(A,B,setOrder)  - Create a mask of A marking elements also in B\n  + setxor(A,B,setOrder)    - Find values of A and B not in both arrays\n  + issorted(A)             - Determine if array is already sorted\n  + isequal(A,B)             -Determine if two sets are equal with a tolerance\n  + bool(expr)              - 1 if logical expression is true, 0 if false. The subsequent data may be produced sorted, or left in the order\n  encountered. EXAMPLES sample program: program demo_M_sets use M_sets , only : & & unique , intersect , union , setdiff , setxor , bool , & & ismember , issorted , isequal character ( len =* ) , parameter :: all = ' (*(g0,1x)) ' character ( len =* ) , parameter :: nl = new_line ( ' A ' ) integer , allocatable :: A ( : ) integer , allocatable :: B ( : ) integer , allocatable :: C ( : ) A = [ 10 , - 10 , 0 , 1 , 2 , 3 , 3 , 2 , 1 , - 10 ] ! print all , nl , & ' UNIQUE ' , ' Find the unique elements of vector A. ' , nl , & ' A= ' , A , nl , & ' sorted= ' , unique ( A ) , nl , & ' stable= ' , unique ( A , setOrder = ' stable ' ) A = [ 5 , 7 , 1 ] B = [ 3 , 1 , 1 ] ! print all , nl , & ' UNION ' , ' Find the union of vectors A and B. ' , nl , & ' A= ' , A , nl , & ' B= ' , B , nl , & ' sorted= ' , union ( A , B , ' sorted ' ) , nl , & ' stable= ' , union ( A , B , ' stable ' ) A = [ 7 , 1 , 7 , 7 , 4 ] B = [ 7 , 0 , 4 , 4 , 0 ] ! print all , nl , & ' INTERSECT ' , ' Find the values common to both A and B. ' , nl , & ' A= ' , A , nl , & ' B= ' , B , nl , & ' sorted= ' , intersect ( A , B ) , nl , & ' stable= ' , intersect ( A , B , setOrder = ' stable ' ) A = [ 3 , 6 , 2 , 1 , 5 , 1 , 1 ] B = [ 2 , 4 , 6 ] ! print all , nl , & ' SETDIFF ' , ' Find the values in A that are not in B. ' , nl , & ' A= ' , A , nl , & ' B= ' , B , nl , & ' sorted= ' , setdiff ( A , B , ' sorted ' ) , nl , & ' stable= ' , setdiff ( A , B , ' stable ' ) A = [ 5 , 3 , 4 , 2 ] B = [ 2 , 4 , 4 , 4 , 6 , 8 ] ! print all , nl , & ' ISMEMBER ' , ' Determine which elements of A are also in B. ' , nl , & ' A= ' , A , nl , & ' B= ' , B , nl , & ' in A and B= ' , ismember ( A , B ) A = [ 5 , 1 , 3 , 3 , 3 ] B = [ 4 , 1 , 2 ] ! print all , nl , & ' SETXOR ' , & ' Find values of A and B not in their intersection. ' , nl , & ' A= ' , A , nl , & ' B= ' , B , nl , & ' sorted= ' , setxor ( A , B ) , nl , & ' stable= ' , setxor ( A , B , ' stable ' ) A = [ 1 , 2 , 3 , 4 , 5 ] B = [ 5 , 4 , 3 , 2 , 1 ] ! print all , nl , & ' ISSSORTED ' , & ' confirm whether array is sorted in ascending order or not ' , nl , & ' A= ' , A , nl , & ' B= ' , B , nl , & ' is A sorted? ' , issorted ( A ) , nl , & ' is B sorted? ' , issorted ( B ) A = [ 1 , 2 , 3 , 4 , 5 ] B = [ 1 , 2 , 3 , 4 , 5 ] ! print all , nl , & ' ISEQUAL ' , & ' confirm whether sets have same elements in same order ' , nl , & ' A= ' , A , nl , & ' B= ' , B , nl , & ' is A equal to B? ' , isequal ( A , B ) , nl , & ' is B equal to -B? ' , isequal ( A , - B ) A = [ 1 , 2 , 3 , 4 , 5 ] B = [ 5 , 2 , 3 , 4 , 1 ] ! print all , nl , & ' BOOL ' , & ' if logical expression is true, 0 if false. ' , nl , & ' A= ' , A , nl , & ' B= ' , B , nl , & ' is A(i) = B(i) ? ' , bool ( A == B ) , nl , & ' how many elements are the same? ' , sum ( bool ( A == B )) end program demo_M_sets Results: UNIQUE Find the unique elements of vector A.\n A= 10 -10 0 1 2 3 3 2 1 -10\n sorted= -10 0 1 2 3 10\n stable= 10 -10 0 1 2 3 UNION Find the union of vectors A and B.\n A= 5 7 1\n B= 3 1 1\n sorted= 1 3 5 7\n stable= 5 7 1 3 INTERSECT Find the values common to both A and B.\n A= 7 1 7 7 4\n B= 7 0 4 4 0\n sorted= 4 7\n stable= 7 4 SETDIFF Find the values in A that are not in B.\n A= 3 6 2 1 5 1 1\n B= 2 4 6\n sorted= 1 3 5\n stable= 3 1 5 ISMEMBER Determine which elements of A are also in B.\n A= 5 3 4 2\n B= 2 4 4 4 6 8\n in A and B= 0 0 1 1 SETXOR Find values of A and B not in their intersection.\n A= 5 1 3 3 3\n B= 4 1 2\n sorted= 2 3 4 5\n stable= 5 3 4 2 ISSSORTED confirm whether array is sorted in ascending order or not\n A= 1 2 3 4 5\n B= 5 4 3 2 1\n is A sorted? 1\n is B sorted? 0 BOOL if logical expression is true, 0 if false.\n A= 1 2 3 4 5\n B= 5 2 3 4 1\n is A(i) = B(i) ? 0 1 1 1 0\n how many elements are the same? 3 AUTHORS John S. Urban, 2023-07-20 LICENSE CC0-1.0 Uses M_orderpack iso_fortran_env Interfaces public        interface bool private pure elemental function bool_expr(expr) NAME bool ( 3 f ) - [ M_sets :: LOGICAL ] returns One if expression is TRUE , else returns Zero . ( LICENSE : PD ) SYNOPSIS pure elemental integer function bool(expr)\n\n logical,intent(in) :: expr\n   or\n character(len=:)intent(in) :: expr\n   or\n integer|real|complex(in) :: expr DESCRIPTION bool(3f) returns an integer 1 given a true logical expression. OPTIONS expr  A logical expression. If any other intrinsic type a blank string is\n       TRUE as well as 0. 0.0, and (0.0,0.0). Non-zero numeric values\n       and non-blank or non-null strings are FALSE. RETURNS The result is a default INTEGER value of 1 if the expression is TRUE,\n   and a 0 otherwise. EXAMPLES Sample usage: program demo_bool use M_sets , only : bool implicit none write ( * , * ) ' is 10 < 20 ? ' , bool ( 10 < 20 ) write ( * , * ) ' elemental ' , bool ( [ 2 > 1 , 3 == 4 , 10 < 5 , 100 > 50 ] ) if ( sum ( bool ( [ 2 > 1 , 3 == 4 , 10 < 5 , 100 > 50 ] )) >= 2 ) then write ( * , * ) ' two or more are true ' endif end program demo_bool Results: > is 10 < 20 ? 1\n > elemental 1 0 0 1\n > two or more are true AUTHOR John S. Urban LICENSE CC0-1.0 Arguments Type Intent Optional Attributes Name logical, intent(in) :: expr Return Value integer private pure elemental function bool_int8(int) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: int Return Value integer private pure elemental function bool_int16(int) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: int Return Value integer private pure elemental function bool_int32(int) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: int Return Value integer private pure elemental function bool_int64(int) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: int Return Value integer private pure elemental function bool_float32(float) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: float Return Value integer private pure elemental function bool_float64(float) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: float Return Value integer private pure elemental function bool_complex32(val) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in) :: val Return Value integer private pure elemental function bool_complex64(val) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in) :: val Return Value integer private pure elemental function bool_char(string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value integer public        interface intersect private  function intersect_c(A, B, setOrder) result(answer) NAME intersect ( 3 f ) - [ M_sets ] Find the values common to both sets A and B SYNOPSIS intersect(A,B, setOrder) DESCRIPTION The values that occur at least once in each set are returned. That is, intersect(3f) returns the data common to both A and B, with\n no repetitions. OPTIONS A input array B input array setOrder May be \" sort \" or \" stable \" . If \" stable \" the values are returned in the order discovered . The default is \" sorted \" , which returns the data in ascending order . EXAMPLES sample program: program demo_intersect\n   use M_sets, only: unique, intersect, union, setdiff, ismember, setxor\n   character(len= ),parameter :: g=’( (g0,1x))’\n   integer, allocatable       :: A(:)\n   integer, allocatable       :: B(:) write(*,g) 'INTERSECT', 'Find the values common to both A and B.'\n   A=[7, 1, 7, 7, 4]\n   B=[7, 0, 4, 4, 0]\n   write(*,g) 'A=', A\n   write(*,g) 'B=', B\n   write(*,g) intersect(A, B)\n   write(*,g) intersect(A, B, setOrder='stable') end program demo_intersect Results: INTERSECT Find the values common to both A and B.\nA= 7 1 7 7 4\nB= 7 0 4 4 0\n4 7\n7 4 AUTHORS John S. Urban, 2023-07-20 LICENSE CC0-1.0 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: A (:) character(len=*), intent(in) :: B (:) character(len=*), intent(in), optional :: setOrder Return Value character(len=:), allocatable, (:) public        interface isequal private  function isequal_c(A, B) result(answer) NAME isequal ( 3 f ) - [ M_sets ] Report if vector A is equal to vector B SYNOPSIS isequal(A,B,TOLERANCE)\n\n  character(len=:)intent(in) :: A,B\n    or\n  integer|real|complex(in) :: A,B\n  real,optional            :: TOLERANCE DESCRIPTION Report if A is equal to B . Equality is defined as the same element values in the same order . A 1 ( true ) is returned when the elements of A have a one - to - one correspondence to the elements of B with the same values in the same order . 0 ( false ) is returned otherwise . OPTIONS A input array to compare against B input array to compare to A TOLERANCE for numeric values consider the corresponding elements of A and B equal if they are equal within the specified tolerance . A , B and TOLERANCE are of the same type and kind . RETURNS 1 if input array A is to array B , 0 otherwise EXAMPLES sample program: program demo_isequal use M_sets , only : isequal character ( len =* ) , parameter :: g = ' (*(g0,1x)) ' integer , allocatable :: A ( : ) integer , allocatable :: B ( : ) write ( * , g ) ' isequal ' , ' Find if A is equal to B. ' A = [ 10 , - 10 , 0 , 1 , 2 , 3 , 3 , 2 , 1 , - 10 ] B = [ 10 , - 10 , 0 , 1 , 2 , 3 , 3 , 2 , 1 , 10 ] write ( * , g ) ' A= ' , A write ( * , g ) ' B= ' , B write ( * , g ) isequal ( A , B ) write ( * , g ) ' isequal ' , ' Find if A is equal to A. ' write ( * , g ) isequal ( A , A ) end program demo_isequal Results: isequal Find the isequal elements of vector A.\nA= 10 -10 0 1 2 3 3 2 1 -10\n0\nA= -10 10 100 201\n1 AUTHORS John S. Urban, 2023-07-20 LICENSE CC0-1.0 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: A (:) character(len=*), intent(in) :: B (:) Return Value integer public        interface ismember private  function ismember_c(a, b) result(answer) NAME ismember ( 3 f ) - [ M_sets ] Create a mask of A marking elements also in B SYNOPSIS ismember(A,B) DESCRIPTION Identifies elements of the first set that are members of the second set\n as well. The returned array is a mask of the first array containing a 1\n (aka. “true”) where the data in A is found in B. Elsewhere, the array\n contains 0 (aka. “false”). OPTIONS A         input array\n B         input array of values to find in vector A. RETURNS A mask of array A with a 1 at locations where the value in that\n position in A is also a value that occurs in B, and with a 0 at\n locations where that value in A was not found in B. EXAMPLES sample program: program demo_ismember use M_sets , only : ismember character ( len =* ) , parameter :: g = ' (*(g0,1x)) ' integer , allocatable :: A ( : ) integer , allocatable :: B ( : ) write ( * , g ) ' ISMEMBER ' , ' Determine which elements of A are also in B. ' A = [ 5 , 3 , 4 , 2 ] B = [ 2 , 4 , 4 , 4 , 6 , 8 ] write ( * , g ) ' A= ' , A write ( * , g ) ' B= ' , B write ( * , g ) ismember ( A , B ) end program demo_ismember Results: ISMEMBER Determine which elements of A are also in B.\nA= 5 3 4 2\nB= 2 4 4 4 6 8\n0 0 1 1 AUTHORS John S. Urban, 2023-07-20 LICENSE CC0-1.0 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: a (:) character(len=*), intent(in) :: b (:) Return Value integer, allocatable, (:) public        interface issorted private  function issorted_c(A) result(answer) NAME issorted ( 3 f ) - [ M_sets ] Report if A is sorted in ascending order or not . SYNOPSIS issorted(A)\n\n  character(len=:)intent(in) :: A\n    or\n  integer|real|complex(in) :: A DESCRIPTION Report if A is sorted in ascending order or not . A 1 ( true ) is returned when the elements of A are listed in ascending order and 0 ( false ) otherwise . OPTIONS A         input array to test RETURNS 1 if input array A is sorted in ascending order , 0 otherwise EXAMPLES sample program: program demo_issorted use M_sets , only : issorted character ( len =* ) , parameter :: g = ' (*(g0,1x)) ' integer , allocatable :: A ( : ) write ( * , g ) ' ISSORTED ' , ' Find the issorted elements of vector A. ' A = [ 10 , - 10 , 0 , 1 , 2 , 3 , 3 , 2 , 1 , - 10 ] write ( * , g ) ' A= ' , A write ( * , g ) issorted ( A ) A = [ - 10 , 10 , 100 , 201 ] write ( * , g ) ' A= ' , A write ( * , g ) issorted ( A ) end program demo_issorted Results: ISSORTED Find the issorted elements of vector A.\nA= 10 -10 0 1 2 3 3 2 1 -10\n0\nA= -10 10 100 201\n1 AUTHORS John S. Urban, 2023-07-20 LICENSE CC0-1.0 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: A (:) Return Value integer public        interface setdiff private  function setdiff_c(a, b, setOrder) result(answer) NAME setdiff ( 3 f ) - [ M_sets ] Find the values in A that are not in B SYNOPSIS setdiff(A,B, setOrder) DESCRIPTION setdiff(3f) returns the data in A that is not in B, with no repetitions. OPTIONS A input array B input array setOrder May be \" sort \" or \" stable \" . If \" stable \" the values are returned in the order discovered . The default is \" sorted \" , which returns the data in ascending order . EXAMPLES sample program: program demo_setdiff use M_sets , only : setdiff character ( len =* ) , parameter :: g = ' (*(g0,1x)) ' integer , allocatable :: A ( : ) integer , allocatable :: B ( : ) write ( * , g ) ' SETDIFF ' , ' Find the values in A that are not in B. ' A = [ 3 , 6 , 2 , 1 , 5 , 1 , 1 ] B = [ 2 , 4 , 6 ] write ( * , g ) ' A= ' , A write ( * , g ) ' B= ' , B write ( * , g ) setdiff ( A , B ) write ( * , g ) setdiff ( [ 4 , 1 , 3 , 2 , 5 ], [ 2 , 1 ], ' sorted ' ) write ( * , g ) setdiff ( [ 4 , 1 , 3 , 2 , 5 ], [ 2 , 1 ], ' stable ' ) end program demo_setdiff Results: SETDIFF Find the values in A that are not in B.\nA= 3 6 2 1 5 1 1\nB= 2 4 6\n1 3 5\n3 4 5\n4 3 5 AUTHORS John S. Urban, 2023-07-20 LICENSE CC0-1.0 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: a (:) character(len=*), intent(in) :: b (:) character(len=*), intent(in), optional :: setOrder Return Value character(len=:), allocatable, (:) public        interface setxor private  function setxor_c(a, b, setOrder) result(answer) NAME setxor ( 3 f ) - [ M_sets ] Find values of A and B not in both arrays SYNOPSIS setxor(A,B, setOrder) DESCRIPTION setxfor(3f) returns the exclusive OR of two arrays. That is, it returns\n the data of A and B that are not in their intersection (the symmetric\n difference), with no repetitions. Another way of defining the result is that setxor(3f) returns the data\n that occurs in A or B, but not both. OPTIONS A input array B input array setOrder May be \" sort \" or \" stable \" . If \" stable \" the values are returned in the order discovered . The default is \" sorted \" , which returns the data in ascending order . EXAMPLES sample program: program demo_setxor use M_sets , only : setxor character ( len =* ) , parameter :: g = ' (*(g0,1x)) ' integer , allocatable :: A ( : ) integer , allocatable :: B ( : ) write ( * , g ) ' SETXOR ' , ' Find values of A and B not in their intersection. ' A = [ 5 , 1 , 3 , 3 , 3 ] B = [ 4 , 1 , 2 ] write ( * , g ) ' A= ' , A write ( * , g ) ' B= ' , B write ( * , g ) setxor ( A , B ) write ( * , g ) setxor ( A , B , ' stable ' ) end program demo_setxor Results: SETXOR Find values of A and B not in their intersection.\nA= 5 1 3 3 3\nB= 4 1 2\n2 3 4 5\n5 3 4 2 AUTHORS John S. Urban, 2023-07-20 LICENSE CC0-1.0 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: a (:) character(len=*), intent(in) :: b (:) character(len=*), intent(in), optional :: setOrder Return Value character(len=:), allocatable, (:) public        interface union private  function union_c(A, B, setOrder) result(answer) NAME union ( 3 f ) - [ M_sets ] Join two sets and removes duplicates of values SYNOPSIS union(A,B, setOrder) DESCRIPTION The two sets are combined and repetitions are removed. OPTIONS A input array B input array setOrder May be \" sort \" or \" stable \" . If \" stable \" the values are returned in the order discovered . The default is \" sorted \" , which returns the data in ascending order . EXAMPLES sample program: program demo_union use M_sets , only : union character ( len =* ) , parameter :: g = ' (*(g0,1x)) ' integer , allocatable :: A ( : ) integer , allocatable :: B ( : ) write ( * , g ) ' UNION ' , ' Find the union of vectors A and B. ' A = [ 5 , 7 , 1 ] B = [ 3 , 1 , 1 ] write ( * , g ) ' A= ' , A write ( * , g ) ' B= ' , B write ( * , g ) union ( A , B ) A = [ 5 , 5 , 3 ] B = [ 1 , 2 , 5 ] write ( * , g ) ' A= ' , A write ( * , g ) ' B= ' , B write ( * , g ) union ( A , B , ' sorted ' ) write ( * , g ) union ( A , B , ' stable ' ) end program demo_union ```\n Results: UNION Find the union of vectors A and B.\nA= 5 7 1\nB= 3 1 1\n1 3 5 7\nA= 5 5 3\nB= 1 2 5\n1 2 3 5\n5 3 1 2 AUTHORS John S. Urban, 2023-07-20 LICENSE CC0-1.0 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: A (:) character(len=*), intent(in) :: B (:) character(len=*), intent(in), optional :: setOrder Return Value character(len=:), allocatable, (:) public        interface unique private  function unique_c(A, setOrder) result(answer) NAME unique ( 3 f ) - [ M_sets ] return unique values in array A SYNOPSIS unique(A,setOrder) DESCRIPTION unique(3) returns the unique values found in an array. That is, it\n eliminates all but one occurrence of each value. The result is in sorted order by default, but may be returned in the\n order found. OPTIONS A input array to extract unique values from setOrder May be \" sort \" or \" stable \" . If \" stable \" the values are returned in the order discovered . The default is \" sorted \" , which returns the data in ascending order . RETURNS All the values that occur in the input occur in the output\n just once. All duplicates are removed. EXAMPLES sample program: program demo_unique use M_sets , only : unique character ( len =* ) , parameter :: g = ' (*(g0,1x)) ' integer , allocatable :: A ( : ) write ( * , g ) ' UNIQUE ' , ' Find the unique elements of vector A. ' A = [ 10 , - 10 , 0 , 1 , 2 , 3 , 3 , 2 , 1 , - 10 ] write ( * , g ) ' A= ' , A write ( * , g ) unique ( A ) write ( * , g ) unique ( A , setOrder = ' stable ' ) end program demo_unique Results: UNIQUE Find the unique elements of vector A.\nA= 10 -10 0 1 2 3 3 2 1 -10\n-10 0 1 2 3 10\n10 -10 0 1 2 3 AUTHORS John S. Urban, 2023-07-20 LICENSE CC0-1.0 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: A (:) character(len=*), intent(in), optional :: setOrder Return Value character(len=:), allocatable, (:)","tags":"","url":"module/m_sets.html"},{"title":"demo_issorted – M_sets","text":"Uses M_sets Variables Type Attributes Name Initial integer, allocatable :: A (:) character(len=*), parameter :: g = '(*(g0,1x))' Source Code program demo_issorted use M_sets , only : issorted character ( len =* ), parameter :: g = '(*(g0,1x))' integer , allocatable :: A (:) write ( * , g ) 'ISSORTED' , 'Find the issorted elements of vector A.' A = [ 10 , - 10 , 0 , 1 , 2 , 3 , 3 , 2 , 1 , - 10 ] write ( * , g ) 'A=' , A write ( * , g ) issorted ( A ) A = [ - 10 , 10 , 100 , 201 ] write ( * , g ) 'A=' , A write ( * , g ) issorted ( A ) end program demo_issorted","tags":"","url":"program/demo_issorted.html"},{"title":"demo_bool – M_sets","text":"Uses M_sets Source Code program demo_bool use M_sets , only : bool implicit none write ( * , * ) 'is 10 < 20 ?' , bool ( 10 < 20 ) write ( * , * ) 'elemental' , bool ([ 2 > 1 , 3 == 4 , 10 < 5 , 100 > 50 ]) if ( sum ( bool ([ 2 > 1 , 3 == 4 , 10 < 5 , 100 > 50 ])) >= 2 ) then write ( * , * ) 'two or more are true' endif end program demo_bool","tags":"","url":"program/demo_bool.html"},{"title":"main – M_sets","text":"Uses M_sets Variables Type Attributes Name Initial integer, allocatable :: A (:) integer, allocatable :: B (:) integer, allocatable :: C (:) character(len=*), parameter :: g = '(*(g0,1x))' integer :: i real :: valsr (1000000) Source Code program main ! measure general performance by operating on 1 000 000, random values use M_sets , only : unique , intersect , union , setdiff , ismember , setxor , bool implicit none real :: valsr ( 1000000 ) integer , allocatable :: A (:) integer , allocatable :: B (:) integer , allocatable :: C (:) integer :: i character ( len =* ), parameter :: g = '(*(g0,1x))' call random_seed () do i = 1 , 10 call random_number ( valsr ) A = valsr * 2 0.0 - 1 0.0 B = [( i , i =- 10 , 10 )] write ( * , g ) A C = unique ( A ) write ( * , g ) 'UNIQUE:    NUMBER OF VALUES RETURNED:' , size ( C ), C C = intersect ( A , B ) write ( * , g ) 'INTERSECT: NUMBER OF VALUES RETURNED:' , size ( C ), C C = union ( A , B ) write ( * , g ) 'UNION:     NUMBER OF VALUES RETURNED:' , size ( C ), C C = setdiff ( A , B ) write ( * , g ) 'SETDIFF:   NUMBER OF VALUES RETURNED:' , size ( C ), C C = ismember ( A , B ) write ( * , g ) 'ISMEMBER:  NUMBER OF VALUES RETURNED:' , size ( C ) C = setxor ( A , B ) write ( * , g ) 'SETXOR:    NUMBER OF VALUES RETURNED:' , size ( C ), C end do end program main","tags":"","url":"program/main.html"},{"title":"demo_M_sets – M_sets","text":"Uses M_sets Variables Type Attributes Name Initial integer, allocatable :: A (:) integer, allocatable :: B (:) integer, allocatable :: C (:) character(len=*), parameter :: all = '(*(g0,1x))' character(len=*), parameter :: nl = new_line('A') Source Code program demo_M_sets use M_sets , only : & & unique , intersect , union , setdiff , setxor , bool , & & ismember , issorted , isequal character ( len =* ), parameter :: all = '(*(g0,1x))' character ( len =* ), parameter :: nl = new_line ( 'A' ) integer , allocatable :: A (:) integer , allocatable :: B (:) integer , allocatable :: C (:) A = [ 10 , - 10 , 0 , 1 , 2 , 3 , 3 , 2 , 1 , - 10 ] ! print all , nl , & 'UNIQUE' , 'Find the unique elements of vector A.' , nl , & 'A=' , A , nl , & 'sorted=' , unique ( A ) , nl , & 'stable=' , unique ( A , setOrder = 'stable' ) A = [ 5 , 7 , 1 ] B = [ 3 , 1 , 1 ] ! print all , nl , & 'UNION' , 'Find the union of vectors A and B.' , nl , & 'A=' , A , nl , & 'B=' , B , nl , & 'sorted=' , union ( A , B , 'sorted' ) , nl , & 'stable=' , union ( A , B , 'stable' ) A = [ 7 , 1 , 7 , 7 , 4 ] B = [ 7 , 0 , 4 , 4 , 0 ] ! print all , nl , & 'INTERSECT' , 'Find the values common to both A and B.' , nl , & 'A=' , A , nl , & 'B=' , B , nl , & 'sorted=' , intersect ( A , B ) , nl , & 'stable=' , intersect ( A , B , setOrder = 'stable' ) A = [ 3 , 6 , 2 , 1 , 5 , 1 , 1 ] B = [ 2 , 4 , 6 ] ! print all , nl , & 'SETDIFF' , 'Find the values in A that are not in B.' , nl , & 'A=' , A , nl , & 'B=' , B , nl , & 'sorted=' , setdiff ( A , B , 'sorted' ) , nl , & 'stable=' , setdiff ( A , B , 'stable' ) A = [ 5 , 3 , 4 , 2 ] B = [ 2 , 4 , 4 , 4 , 6 , 8 ] ! print all , nl , & 'ISMEMBER' , 'Determine which elements of A are also in B.' , nl , & 'A=' , A , nl , & 'B=' , B , nl , & 'in A and B=' , ismember ( A , B ) A = [ 5 , 1 , 3 , 3 , 3 ] B = [ 4 , 1 , 2 ] ! print all , nl , & 'SETXOR' , & 'Find values of A and B not in their intersection.' , nl , & 'A=' , A , nl , & 'B=' , B , nl , & 'sorted=' , setxor ( A , B ) , nl , & 'stable=' , setxor ( A , B , 'stable' ) A = [ 1 , 2 , 3 , 4 , 5 ] B = [ 5 , 4 , 3 , 2 , 1 ] ! print all , nl , & 'ISSSORTED' , & 'confirm whether array is sorted in ascending order or not' , nl , & 'A=' , A , nl , & 'B=' , B , nl , & 'is A sorted?' , issorted ( A ) , nl , & 'is B sorted?' , issorted ( B ) A = [ 1 , 2 , 3 , 4 , 5 ] B = [ 1 , 2 , 3 , 4 , 5 ] ! print all , nl , & 'ISEQUAL' , & 'confirm whether sets have same elements in same order    ' , nl , & 'A=' , A , nl , & 'B=' , B , nl , & 'is A equal to B?' , isequal ( A , B ) , nl , & 'is B equal to -B?' , isequal ( A , - B ) A = [ 1 , 2 , 3 , 4 , 5 ] B = [ 5 , 2 , 3 , 4 , 1 ] ! print all , nl , & 'BOOL' , & 'if logical expression is true, 0 if false.' , nl , & 'A=' , A , nl , & 'B=' , B , nl , & 'is A(i) = B(i) ?' , bool ( A == B ) , nl , & 'how many elements are the same?' , sum ( bool ( A == B )) end program demo_M_sets","tags":"","url":"program/demo_m_sets.html"},{"title":"runtest – M_sets","text":"Uses M_sets iso_fortran_env M_framework Variables Type Attributes Name Initial integer, allocatable :: a (:) integer, allocatable :: b (:) integer, allocatable :: c (:) integer, allocatable :: expected (:) real, allocatable :: fltA (:) real, allocatable :: fltB (:) real, allocatable :: fltC (:) real, allocatable :: fltexpected (:) character(len=:), allocatable :: strA (:) character(len=:), allocatable :: strB (:) character(len=:), allocatable :: strC (:) character(len=:), allocatable :: strexpected (:) Subroutines subroutine test_bool () Arguments None subroutine test_intersect () Arguments None subroutine test_isequal () Arguments None subroutine test_ismember () Arguments None subroutine test_issorted () Arguments None subroutine test_setdiff () Arguments None subroutine test_setxor () Arguments None subroutine test_union () Arguments None subroutine test_unique () Arguments None Source Code program runtest use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 use M_framework use M_sets , only : unique , intersect , union , setdiff , ismember , setxor , issorted , isequal , bool ! implicit none integer , allocatable :: a (:) integer , allocatable :: b (:) integer , allocatable :: c (:) integer , allocatable :: expected (:) real , allocatable :: fltA (:) real , allocatable :: fltB (:) real , allocatable :: fltC (:) real , allocatable :: fltexpected (:) character ( len = :), allocatable :: strA (:) character ( len = :), allocatable :: strB (:) character ( len = :), allocatable :: strC (:) character ( len = :), allocatable :: strexpected (:) unit_test_level = 0 call test_unique () call test_intersect () call test_union () call test_setdiff () call test_ismember () call test_setxor () call test_issorted () call test_isequal () call test_bool () call unit_test_stop () contains !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_unique call unit_test_start ( 'unique' , 'find the unique elements of vactor A' ) ! start tests A = [ 10 , - 10 , 0 , 1 , 2 , 3 , 3 , 2 , 1 , - 10 ] strA = [ 'ab' , 'AB' , 'zz' , 'mq' , 'qm' , 'mq' , 'Za' , 'zz' , 'bb' , 'qm' ] C = unique ( A ) expected = [ - 10 , 0 , 1 , 2 , 3 , 10 ] call unit_test ( 'unique' , size ( C ). eq . size ( expected ), 'sorted size' ) if ( size ( C ). eq . size ( expected )) then call unit_test ( 'unique' , all ( C . eq . expected ), 'sorted, expected' , str ( expected ), 'got' , str ( C )) endif C = unique ( A , setOrder = 'stable' ) expected = [ 10 , - 10 , 0 , 1 , 2 , 3 ] call unit_test ( 'unique' , size ( C ). eq . size ( expected ), 'stable size' ) if ( size ( C ). eq . size ( expected )) then call unit_test ( 'unique' , all ( C . eq . expected ), 'stable, expected' , str ( expected ), 'got' , str ( C )) endif strC = unique ( strA , setorder = 'stable' ) strexpected = [ 'ab' , 'AB' , 'zz' , 'mq' , 'qm' , 'Za' , 'bb' ] call unit_test ( 'unique' , size ( strC ). eq . size ( strexpected ), 'sorted size' ) if ( size ( strC ). eq . size ( strexpected )) then call unit_test ( 'unique' , all ( strC . eq . strexpected ), 'stable, expected' , str ( strexpected ), 'got' , str ( strC )) endif strC = unique ( strA , setorder = 'sorted' ) strexpected = [ \"AB\" , \"Za\" , \"ab\" , \"bb\" , \"mq\" , \"qm\" , \"zz\" ] call unit_test ( 'unique' , size ( strC ). eq . size ( strexpected ), 'sorted size' ) if ( size ( strC ). eq . size ( strexpected )) then call unit_test ( 'unique' , all ( strC . eq . strexpected ), 'sorted, expected' , str ( strexpected ), 'got' , str ( strC )) endif fltA = [ 1 0.1 , - 1 0.0 , 0.0 , 1.11 , 2.22 , 3.33 , 3.33 , 2.22 , 1.11 , - 1 0.0 ] fltC = unique ( fltA ) fltexpected = [ - 1 0.0 , 0.0 , 1.11 , 2.22 , 3.33 , 1 0.1 ] call unit_test ( 'unique' , size ( fltC ). eq . size ( fltexpected ), 'sorted size' ) if ( size ( fltC ). eq . size ( fltexpected )) then call unit_test ( 'unique' , all ( fltC . eq . fltexpected ), 'sorted, expected' , str ( fltexpected ), 'got' , str ( fltC )) endif fltC = unique ( fltA , setOrder = 'stable' ) fltexpected = [ 1 0.1 , - 1 0.0 , 0.0 , 1.11 , 2.22 , 3.33 ] call unit_test ( 'unique' , size ( fltC ). eq . size ( fltexpected ), 'stable size' ) if ( size ( fltC ). eq . size ( fltexpected )) then call unit_test ( 'unique' , all ( fltC . eq . fltexpected ), 'stable, expected' , str ( fltexpected ), 'got' , str ( fltC )) endif call unit_test_done ( 'unique' , msg = 'test completed' ) end subroutine test_unique !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_union call unit_test_start ( 'union' , 'find the unique elements of vactors A and B' ) ! start tests A = [ 5 , 7 , 1 ] B = [ 3 , 1 , 1 ] C = union ( A , B ) expected = [ 1 , 3 , 5 , 7 ] call unit_test ( 'union' , size ( C ). eq . size ( expected ), 'sorted size' ) if ( size ( C ). eq . size ( expected )) then call unit_test ( 'union' , all ( C . eq . expected ), 'default, expected' , str ( expected ), 'got' , str ( C )) endif A = [ 5 , 5 , 3 ] B = [ 1 , 2 , 5 ] C = union ( A , B , 'sorted' ) expected = [ 1 , 2 , 3 , 5 ] call unit_test ( 'union' , size ( C ). eq . size ( expected ), 'sorted size' ) if ( size ( C ). eq . size ( expected )) then call unit_test ( 'union' , all ( C . eq . expected ), 'sorted, expected' , str ( expected ), 'got' , str ( C )) endif C = union ( A , B , 'stable' ) expected = [ 5 , 3 , 1 , 2 ] call unit_test ( 'union' , size ( C ). eq . size ( expected ), 'stable size' ) if ( size ( C ). eq . size ( expected )) then call unit_test ( 'union' , all ( C . eq . expected ), 'stable, expected' , str ( expected ), 'got' , str ( C )) endif strA = [ \"5\" , \"7\" , \"1\" ] strB = [ \"3\" , \"1\" , \"1\" ] strC = union ( strA , strB ) strexpected = [ \"1\" , \"3\" , \"5\" , \"7\" ] call unit_test ( 'union' , size ( strC ). eq . size ( strexpected ), 'default size' , 'expected' , size ( strexpected ), 'got' , size ( strC )) if ( size ( strC ). eq . size ( strexpected )) then call unit_test ( 'union' , all ( strC . eq . strexpected ), 'default, expected' , str ( strexpected ), 'got' , str ( strC )) endif strA = [ \"5\" , \"5\" , \"3\" ] strB = [ \"1\" , \"2\" , \"5\" ] strC = union ( strA , strB , 'sorted' ) strexpected = [ \"1\" , \"2\" , \"3\" , \"5\" ] call unit_test ( 'union' , size ( strC ). eq . size ( strexpected ), 'sorted size' , 'expected' , size ( strexpected ), 'got' , size ( strC )) if ( size ( strC ). eq . size ( strexpected )) then call unit_test ( 'union' , all ( strC . eq . strexpected ), 'sorted, expected' , str ( strexpected ), 'got' , str ( strC )) endif strC = union ( strA , strB , 'stable' ) strexpected = [ \"5\" , \"3\" , \"1\" , \"2\" ] call unit_test ( 'union' , size ( strC ). eq . size ( strexpected ), 'stable size' , 'expected' , size ( strexpected ), 'got' , size ( strC )) if ( size ( strC ). eq . size ( strexpected )) then call unit_test ( 'union' , all ( strC . eq . strexpected ), 'stable, expected' , str ( strexpected ), 'got' , str ( strC )) endif fltA = [ 5.5 , 7.0 , 1.2345 ] fltB = [ 3.333 , 1.2345 , 1.2345 ] fltC = union ( fltA , fltB ) fltexpected = [ 1.2345 , 3.333 , 5.5 , 7.0 ] call unit_test ( 'union' , size ( fltC ). eq . size ( fltexpected ), 'sorted size' ) if ( size ( fltC ). eq . size ( fltexpected )) then call unit_test ( 'union' , all ( fltC . eq . fltexpected ), 'default, expected' , str ( fltexpected ), 'got' , str ( fltC )) endif fltA = [ 5.5 , 5.5 , 3.333 ] fltB = [ 1.234 , 2.0 , 5.5 ] fltC = union ( fltA , fltB , 'sorted' ) fltexpected = [ 1.234 , 2.0 , 3.333 , 5.5 ] call unit_test ( 'union' , size ( fltC ). eq . size ( fltexpected ), 'sorted size' ) if ( size ( fltC ). eq . size ( fltexpected )) then call unit_test ( 'union' , all ( fltC . eq . fltexpected ), 'sorted, expected' , str ( fltexpected ), 'got' , str ( fltC )) endif fltC = union ( fltA , fltB , 'stable' ) fltexpected = [ 5.5 , 3.333 , 1.234 , 2.0 ] call unit_test ( 'union' , size ( fltC ). eq . size ( fltexpected ), 'stable size' ) if ( size ( fltC ). eq . size ( fltexpected )) then call unit_test ( 'union' , all ( fltC . eq . fltexpected ), 'stable, expected' , str ( fltexpected ), 'got' , str ( fltC )) endif call unit_test_done ( 'union' , msg = 'test completed' ) end subroutine test_union !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_intersect call unit_test_start ( 'intersect' , 'find the values common to both A and B' ) ! start tests A = [ 7 , 1 , 7 , 7 , 4 ] B = [ 7 , 0 , 4 , 4 , 0 ] C = intersect ( A , B ) expected = [ 4 , 7 ] call unit_test ( 'intersect' , size ( C ). eq . size ( expected ), 'sorted size' , 'expected' , size ( expected ), 'got' , size ( c )) if ( size ( C ). eq . size ( expected )) then call unit_test ( 'intersect' , all ( C . eq . expected ), 'sorted, expected' , str ( expected ), 'got' , str ( C )) endif C = intersect ( A , B , 'stable' ) expected = [ 7 , 4 ] call unit_test ( 'intersect' , size ( C ). eq . size ( expected ), 'stable size' , 'expected' , size ( expected ), 'got' , size ( c )) if ( size ( C ). eq . size ( expected )) then call unit_test ( 'intersect' , all ( C . eq . expected ), 'stable, expected' , str ( expected ), 'got' , str ( C )) endif strA = [ \"7\" , \"1\" , \"7\" , \"7\" , \"4\" ] strB = [ \"7\" , \"0\" , \"4\" , \"4\" , \"0\" ] strC = intersect ( strA , strB ) strexpected = [ \"4\" , \"7\" ] call unit_test ( 'intersect' , size ( strC ). eq . size ( strexpected ), 'sorted size' ,& 'expected' , size ( strexpected ), 'got' , size ( strc ), 'output=' , str ( strC )) if ( size ( C ). eq . size ( strexpected )) then call unit_test ( 'intersect' , all ( strC . eq . strexpected ), 'sorted, expected' , str ( strexpected ), 'got' , str ( strC )) endif strC = intersect ( strA , strB , 'stable' ) strexpected = [ \"7\" , \"4\" ] call unit_test ( 'intersect' , size ( strC ). eq . size ( strexpected ), 'stable size' ,& 'expected' , size ( strexpected ), 'got' , size ( strc ), 'output=' , str ( strc )) if ( size ( C ). eq . size ( strexpected )) then call unit_test ( 'intersect' , all ( strC . eq . strexpected ), 'stable, expected' , str ( strexpected ), 'got' , str ( strC )) endif fltA = [ 7.777 , 1.111 , 7.777 , 7.777 , 4.444 ] fltB = [ 7.777 , 0.000 , 4.444 , 4.444 , 0.000 ] fltC = intersect ( fltA , fltB ) fltexpected = [ 4.444 , 7.777 ] call unit_test ( 'intersect' , size ( fltC ). eq . size ( fltexpected ), 'sorted size' ,& & 'expected' , size ( fltexpected ), 'got' , size ( fltc )) if ( size ( fltC ). eq . size ( fltexpected )) then call unit_test ( 'intersect' , all ( fltC . eq . fltexpected ), 'sorted, expected' , str ( fltexpected ), 'got' , str ( fltC )) endif fltC = intersect ( fltA , fltB , 'stable' ) fltexpected = [ 7.777 , 4.444 ] call unit_test ( 'intersect' , size ( fltC ). eq . size ( fltexpected ), 'stable size' ,& & 'expected' , size ( fltexpected ), 'got' , size ( fltc )) if ( size ( fltC ). eq . size ( fltexpected )) then call unit_test ( 'intersect' , all ( fltC . eq . fltexpected ), 'stable, expected' , str ( fltexpected ), 'got' , str ( fltC )) endif call unit_test_done ( 'intersect' , msg = 'test completed' ) end subroutine test_intersect !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_setdiff call unit_test_start ( 'setdiff' , 'find the values in A that are not in B' ) ! start tests A = [ 3 , 6 , 2 , 1 , 5 , 1 , 1 ] B = [ 2 , 4 , 6 ] C = setdiff ( A , B ) expected = [ 1 , 3 , 5 ] call unit_test ( 'setdiff' , size ( C ). eq . size ( expected ), 'sorted size' ) if ( size ( C ). eq . size ( expected )) then call unit_test ( 'setdiff' , all ( C . eq . expected ), 'sorted, expected' , str ( expected ), 'got' , str ( C )) endif A = [ 4 , 1 , 3 , 2 , 5 ] B = [ 2 , 1 ] C = setdiff ( A , B , 'sorted' ) expected = [ 3 , 4 , 5 ] call unit_test ( 'setdiff' , size ( C ). eq . size ( expected ), 'stable size' ) if ( size ( C ). eq . size ( expected )) then call unit_test ( 'setdiff' , all ( C . eq . expected ), 'stable, expected' , str ( expected ), 'got' , str ( C )) endif C = setdiff ( A , B , 'stable' ) expected = [ 4 , 3 , 5 ] call unit_test ( 'setdiff' , size ( C ). eq . size ( expected ), 'stable size' ) if ( size ( C ). eq . size ( expected )) then call unit_test ( 'setdiff' , all ( C . eq . expected ), 'stable, expected' , str ( expected ), 'got' , str ( C )) endif strA = [ '3' , '6' , '2' , '1' , '5' , '1' , '1' ] strB = [ '2' , '4' , '6' ] strC = setdiff ( strA , strB ) strexpected = [ '1' , '3' , '5' ] call unit_test ( 'setdiff' , size ( strC ). eq . size ( strexpected ), 'sorted size' ) if ( size ( C ). eq . size ( strexpected )) then call unit_test ( 'setdiff' , all ( strC . eq . strexpected ), 'sorted, expected' , str ( strexpected ), 'got' , str ( strC )) endif strA = [ '4' , '1' , '3' , '2' , '5' ] strB = [ '2' , '1' ] strC = setdiff ( strA , strB , 'sorted' ) strexpected = [ '3' , '4' , '5' ] call unit_test ( 'setdiff' , size ( strC ). eq . size ( strexpected ), 'stable size' ) if ( size ( C ). eq . size ( strexpected )) then call unit_test ( 'setdiff' , all ( strC . eq . strexpected ), 'stable, expected' , str ( strexpected ), 'got' , str ( strC )) endif strC = setdiff ( strA , strB , 'stable' ) strexpected = [ '4' , '3' , '5' ] call unit_test ( 'setdiff' , size ( strC ). eq . size ( strexpected ), 'stable size' ) if ( size ( C ). eq . size ( strexpected )) then call unit_test ( 'setdiff' , all ( strC . eq . strexpected ), 'stable, expected' , str ( strexpected ), 'got' , str ( strC )) endif fltA = [ 3.456 , 6.54321 , 2.01 , 1.008 , 5.35 , 1.008 , 1.008 ] fltB = [ 2.01 , 4.6853 , 6.54321 ] fltC = setdiff ( fltA , fltB ) fltexpected = [ 1.008 , 3.456 , 5.35 ] call unit_test ( 'setdiff' , size ( fltC ). eq . size ( strexpected ), 'sorted size' ) if ( size ( fltC ). eq . size ( strexpected )) then call unit_test ( 'setdiff' , all ( fltC . eq . fltexpected ), 'sorted, expected' , str ( fltexpected ), 'got' , str ( fltC )) endif fltA = [ 4.6853 , 1.008 , 3.456 , 2.01 , 5.35 ] fltB = [ 2.01 , 1.008 ] fltC = setdiff ( fltA , fltB , 'sorted' ) fltexpected = [ 3.456 , 4.6853 , 5.35 ] call unit_test ( 'setdiff' , size ( fltC ). eq . size ( fltexpected ), 'stable size' ) if ( size ( fltC ). eq . size ( fltexpected )) then call unit_test ( 'setdiff' , all ( fltC . eq . fltexpected ), 'stable, expected' , str ( fltexpected ), 'got' , str ( fltC )) endif fltC = setdiff ( fltA , fltB , 'stable' ) fltexpected = [ 4.6853 , 3.456 , 5.35 ] call unit_test ( 'setdiff' , size ( fltC ). eq . size ( fltexpected ), 'stable size' ) if ( size ( fltC ). eq . size ( fltexpected )) then call unit_test ( 'setdiff' , all ( fltC . eq . fltexpected ), 'stable, expected' , str ( fltexpected ), 'got' , str ( fltC )) endif call unit_test_done ( 'setdiff' , msg = 'test completed' ) end subroutine test_setdiff !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_setxor call unit_test_start ( 'setxor' , 'find values two vectors do not share' ) ! start tests A = [ 5 , 1 , 3 , 3 , 3 ] B = [ 4 , 1 , 2 ] C = setxor ( A , B ) expected = [ 2 , 3 , 4 , 5 ] call unit_test ( 'setxor' , size ( C ). eq . size ( expected ), 'sorted size' ) if ( size ( C ). eq . size ( expected )) then call unit_test ( 'setxor' , all ( C . eq . expected ), 'sorted, expected' , str ( expected ), 'got' , str ( C )) endif C = setxor ( A , B , 'stable' ) expected = [ 5 , 3 , 4 , 2 ] call unit_test ( 'setxor' , size ( C ). eq . size ( expected ), 'stable size' ) if ( size ( C ). eq . size ( expected )) then call unit_test ( 'setxor' , all ( C . eq . expected ), 'stable, expected' , str ( expected ), 'got' , str ( C )) endif strA = [ \"5\" , \"1\" , \"3\" , \"3\" , \"3\" ] strB = [ \"4\" , \"1\" , \"2\" ] strC = setxor ( strA , strB ) strexpected = [ \"2\" , \"3\" , \"4\" , \"5\" ] call unit_test ( 'setxor' , size ( strC ). eq . size ( strexpected ), 'sorted size' ) if ( size ( strC ). eq . size ( strexpected )) then call unit_test ( 'setxor' , all ( strC . eq . strexpected ), 'sorted, expected' , str ( strexpected ), 'got' , str ( strC )) endif strC = setxor ( strA , strB , 'stable' ) strexpected = [ \"5\" , \"3\" , \"4\" , \"2\" ] call unit_test ( 'setxor' , size ( strC ). eq . size ( strexpected ), 'sorted size' ) if ( size ( strC ). eq . size ( strexpected )) then call unit_test ( 'setxor' , all ( strC . eq . strexpected ), 'stable, expected' , str ( strexpected ), 'got' , str ( strC )) endif fltA = [ 5.4321 , 1.11111 , 3.55555 , 3.55555 , 3.55555 ] fltB = [ 4.9087 , 1.11111 , 2.0000 ] fltC = setxor ( fltA , fltB ) fltexpected = [ 2.0000 , 3.55555 , 4.9087 , 5.4321 ] call unit_test ( 'setxor' , size ( fltC ). eq . size ( fltexpected ), 'sorted size' ) if ( size ( fltC ). eq . size ( fltexpected )) then call unit_test ( 'setxor' , all ( fltC . eq . fltexpected ), 'sorted, expected' , str ( fltexpected ), 'got' , str ( fltC )) endif fltC = setxor ( fltA , fltB , 'stable' ) fltexpected = [ 5.4321 , 3.55555 , 4.9087 , 2.0000 ] call unit_test ( 'setxor' , size ( fltC ). eq . size ( fltexpected ), 'sorted size' ) if ( size ( fltC ). eq . size ( fltexpected )) then call unit_test ( 'setxor' , all ( fltC . eq . fltexpected ), 'stable, expected' , str ( fltexpected ), 'got' , str ( fltC )) endif call unit_test_done ( 'setxor' , msg = 'test completed' ) end subroutine test_setxor !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_ismember call unit_test_start ( 'ismember' , 'report which values in A are also in B' ) ! start tests ! ! Create two vectors with values in common. A = [ 5 , 3 , 4 , 2 ] B = [ 2 , 4 , 4 , 4 , 6 , 8 ] C = ismember ( A , B ) expected = [ 0 , 0 , 1 , 1 ] call unit_test ( 'ismember' , size ( C ). eq . size ( expected ), 'sorted size' ) if ( size ( C ). eq . size ( expected )) then call unit_test ( 'ismember' , all ( C . eq . expected ), 'sorted, expected' , str ( expected ), 'got' , str ( C )) endif strA = [ \"5\" , \"3\" , \"4\" , \"2\" ] strB = [ \"2\" , \"4\" , \"4\" , \"4\" , \"6\" , \"8\" ] C = ismember ( strA , strB ) expected = [ 0 , 0 , 1 , 1 ] call unit_test ( 'ismember' , size ( C ). eq . size ( expected ), 'sorted size' ) if ( size ( C ). eq . size ( expected )) then call unit_test ( 'ismember' , all ( C . eq . expected ), 'sorted, expected' , str ( expected ), 'got' , str ( C )) endif fltA = [ 5.5421 , 3.5421 , 4.5421 , 2.5421 ] fltB = [ 2.5421 , 4.5421 , 4.5421 , 4.5421 , 6.5421 , 8.5421 ] C = ismember ( fltA , fltB ) expected = [ 0 , 0 , 1 , 1 ] call unit_test ( 'ismember' , size ( C ). eq . size ( expected ), 'sorted size' ) if ( size ( C ). eq . size ( expected )) then call unit_test ( 'ismember' , all ( C . eq . expected ), 'sorted, expected' , str ( expected ), 'got' , str ( C )) endif call unit_test_done ( 'ismember' , msg = 'test completed' ) end subroutine test_ismember !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_isequal use M_sets , only : isequal call unit_test_start ( 'isequal' , 'Find if vector A and B are identical.' ) A = [ 10 , - 10 , 0 , 1 , 2 , 3 , 3 , 2 , 1 , - 10 ] B = [ 10 , - 10 , 0 , 1 , 2 , 3 , - 3 , 2 , 1 , - 10 ] call unit_test ( 'isequal' , isequal ( A , B ). eq . 0 , 'integer A,B expected 0 got' , isequal ( A , B )) call unit_test ( 'isequal' , isequal ( A , A ). eq . 1 , 'integer A,A expected 1 got' , isequal ( A , A )) strA = [ \"0\" , \"0\" , \"1\" , \"2\" , \"3\" , \"3\" , \"2\" , \"1\" ] strB = [ \"0\" , \"O\" , \"1\" , \"2\" , \"3\" , \"3\" , \"2\" , \"1\" ] call unit_test ( 'isequal' , isequal ( strA , strB ). eq . 0 , 'string A,B expected 0 got' , isequal ( strA , strB )) call unit_test ( 'isequal' , isequal ( strA , strA ). eq . 1 , 'string A,A expected 1 got' , isequal ( strA , strA )) fltA = [ 0.5469 , 0.5469 , 1.5469 , 2.5469 , 3.5469 , 3.5469 , 2.5469 , 1.5469 ] fltB = [ 0.5469 , 0.5469 , 1.5469 , 2.5469 , 3.5469 , 3.4569 , 2.5469 , 1.5469 ] call unit_test ( 'isequal' , isequal ( fltA , fltB ). eq . 0 , 'flting A,B expected 0 got' , isequal ( fltA , fltB )) call unit_test ( 'isequal' , isequal ( fltA , fltA ). eq . 1 , 'flting A,A expected 1 got' , isequal ( fltA , fltA )) end subroutine test_isequal !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_issorted use M_sets , only : issorted call unit_test_start ( 'issorted' , 'Find the issorted elements of vector A.' ) A = [ 10 , - 10 , 0 , 1 , 2 , 3 , 3 , 2 , 1 , - 10 ] call unit_test ( 'issorted' , issorted ( A ). eq . 0 , 'sorted, expected 0 got' , issorted ( A )) A = [ - 10 , 10 , 100 , 201 ] call unit_test ( 'issorted' , issorted ( A ). eq . 1 , 'sorted, expected 1 got' , issorted ( A )) strA = [ \"0\" , \"0\" , \"1\" , \"2\" , \"3\" , \"3\" , \"2\" , \"1\" ] call unit_test ( 'issorted' , issorted ( strA ). eq . 0 , 'sorted, expected 0 got' , issorted ( strA )) strA = [ \"10\" , \"20\" , \"30\" ] call unit_test ( 'issorted' , issorted ( strA ). eq . 1 , 'sorted, expected 1 got' , issorted ( strA )) fltA = [ 0.5469 , 0.5469 , 1.5469 , 2.5469 , 3.5469 , 3.5469 , 2.5469 , 1.5469 ] call unit_test ( 'issorted' , issorted ( fltA ). eq . 0 , 'sorted, expected 0 got' , issorted ( fltA )) fltA = [ 1 0.5469 , 2 0.5469 , 3 0.5469 ] call unit_test ( 'issorted' , issorted ( fltA ). eq . 1 , 'sorted, expected 1 got' , issorted ( fltA )) end subroutine test_issorted !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_bool use M_sets , only : bool call unit_test_start ( 'bool' , 'convert logical to integer. 1 is true, 0 is false.' ) call unit_test ( 'bool' , bool ( 10 < 20 ). eq . 1 , 'true expression' , bool ( 10 < 20 )) call unit_test ( 'bool' , bool ( 10 > 20 ). eq . 0 , 'false expression' , bool ( 10 > 20 )) call unit_test ( 'bool' , all ( bool ([ 2 > 1 , 3 == 4 , 10 < 5 , 100 > 50 ]). eq .[ 1 , 0 , 0 , 1 ]), 'elemental' ) A = [ 10 , - 10 , 0 , 1 , 2 , 3 , 3 , 2 , 1 , - 10 ] call unit_test ( 'bool' , all ( bool ( A ). eq .[ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]), 'integers' , str ( bool ( A ))) strA = [ \"0\" , \"0\" , \"1\" , \"2\" , \"3\" , \"3\" , \"2\" , \"1\" ] call unit_test ( 'bool' , all ( bool ( strA ). eq .[ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]), 'strings' , str ( bool ( strA ))) fltA = [ 0.5469 , 0.5469 , 1.5469 , 2.5469 , 3.5469 , 3.5469 , 2.5469 , 1.5469 ] call unit_test ( 'bool' , all ( bool ( fltA ). eq .[ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]), 'real' , str ( bool ( fltA ))) end subroutine test_bool !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT end program runtest","tags":"","url":"program/runtest.html"},{"title":"demo_unique – M_sets","text":"Uses M_sets Variables Type Attributes Name Initial integer, allocatable :: A (:) character(len=*), parameter :: g = '(*(g0,1x))' Source Code program demo_unique use M_sets , only : unique character ( len =* ), parameter :: g = '(*(g0,1x))' integer , allocatable :: A (:) write ( * , g ) 'UNIQUE' , 'Find the unique elements of vector A.' A = [ 10 , - 10 , 0 , 1 , 2 , 3 , 3 , 2 , 1 , - 10 ] write ( * , g ) 'A=' , A write ( * , g ) unique ( A ) write ( * , g ) unique ( A , setOrder = 'stable' ) end program demo_unique","tags":"","url":"program/demo_unique.html"},{"title":"demo_setxor – M_sets","text":"Uses M_sets Variables Type Attributes Name Initial integer, allocatable :: A (:) integer, allocatable :: B (:) character(len=*), parameter :: g = '(*(g0,1x))' Source Code program demo_setxor use M_sets , only : setxor character ( len =* ), parameter :: g = '(*(g0,1x))' integer , allocatable :: A (:) integer , allocatable :: B (:) write ( * , g ) 'SETXOR' , 'Find values of A and B not in their intersection.' A = [ 5 , 1 , 3 , 3 , 3 ] B = [ 4 , 1 , 2 ] write ( * , g ) 'A=' , A write ( * , g ) 'B=' , B write ( * , g ) setxor ( A , B ) write ( * , g ) setxor ( A , B , 'stable' ) end program demo_setxor","tags":"","url":"program/demo_setxor.html"},{"title":"demo_setdiff – M_sets","text":"Uses M_sets Variables Type Attributes Name Initial integer, allocatable :: A (:) integer, allocatable :: B (:) character(len=*), parameter :: g = '(*(g0,1x))' Source Code program demo_setdiff use M_sets , only : setdiff character ( len =* ), parameter :: g = '(*(g0,1x))' integer , allocatable :: A (:) integer , allocatable :: B (:) write ( * , g ) 'SETDIFF' , 'Find the values in A that are not in B.' A = [ 3 , 6 , 2 , 1 , 5 , 1 , 1 ] B = [ 2 , 4 , 6 ] write ( * , g ) 'A=' , A write ( * , g ) 'B=' , B write ( * , g ) setdiff ( A , B ) write ( * , g ) setdiff ([ 4 , 1 , 3 , 2 , 5 ], [ 2 , 1 ], 'sorted' ) write ( * , g ) setdiff ([ 4 , 1 , 3 , 2 , 5 ], [ 2 , 1 ], 'stable' ) end program demo_setdiff","tags":"","url":"program/demo_setdiff.html"},{"title":"demo_union – M_sets","text":"Uses M_sets Variables Type Attributes Name Initial integer, allocatable :: A (:) integer, allocatable :: B (:) character(len=*), parameter :: g = '(*(g0,1x))' Source Code program demo_union use M_sets , only : union character ( len =* ), parameter :: g = '(*(g0,1x))' integer , allocatable :: A (:) integer , allocatable :: B (:) write ( * , g ) 'UNION' , 'Find the union of vectors A and B.' A = [ 5 , 7 , 1 ] B = [ 3 , 1 , 1 ] write ( * , g ) 'A=' , A write ( * , g ) 'B=' , B write ( * , g ) union ( A , B ) A = [ 5 , 5 , 3 ] B = [ 1 , 2 , 5 ] write ( * , g ) 'A=' , A write ( * , g ) 'B=' , B write ( * , g ) union ( A , B , 'sorted' ) write ( * , g ) union ( A , B , 'stable' ) end program demo_union","tags":"","url":"program/demo_union.html"},{"title":"demo_intersect – M_sets","text":"Uses M_sets Variables Type Attributes Name Initial integer, allocatable :: A (:) integer, allocatable :: B (:) character(len=*), parameter :: g = '(*(g0,1x))' Source Code program demo_intersect use M_sets , only : unique , intersect , union , setdiff , ismember , setxor character ( len =* ), parameter :: g = '(*(g0,1x))' integer , allocatable :: A (:) integer , allocatable :: B (:) write ( * , g ) 'INTERSECT' , 'Find the values common to both A and B.' A = [ 7 , 1 , 7 , 7 , 4 ] B = [ 7 , 0 , 4 , 4 , 0 ] write ( * , g ) 'A=' , A write ( * , g ) 'B=' , B write ( * , g ) intersect ( A , B ) write ( * , g ) intersect ( A , B , setOrder = 'stable' ) end program demo_intersect","tags":"","url":"program/demo_intersect.html"},{"title":"demo_isequal – M_sets","text":"Uses M_sets Variables Type Attributes Name Initial integer, allocatable :: A (:) integer, allocatable :: B (:) character(len=*), parameter :: g = '(*(g0,1x))' Source Code program demo_isequal use M_sets , only : isequal character ( len =* ), parameter :: g = '(*(g0,1x))' integer , allocatable :: A (:) integer , allocatable :: B (:) write ( * , g ) 'isequal' , 'Find if A is equal to B. ' A = [ 10 , - 10 , 0 , 1 , 2 , 3 , 3 , 2 , 1 , - 10 ] B = [ 10 , - 10 , 0 , 1 , 2 , 3 , 3 , 2 , 1 , 10 ] write ( * , g ) 'A=' , A write ( * , g ) 'B=' , B write ( * , g ) isequal ( A , B ) write ( * , g ) 'isequal' , 'Find if A is equal to A. ' write ( * , g ) isequal ( A , A ) end program demo_isequal","tags":"","url":"program/demo_isequal.html"},{"title":"demo_ismember – M_sets","text":"Uses M_sets Variables Type Attributes Name Initial integer, allocatable :: A (:) integer, allocatable :: B (:) character(len=*), parameter :: g = '(*(g0,1x))' Source Code program demo_ismember use M_sets , only : ismember character ( len =* ), parameter :: g = '(*(g0,1x))' integer , allocatable :: A (:) integer , allocatable :: B (:) write ( * , g ) 'ISMEMBER' , 'Determine which elements of A are also in B.' A = [ 5 , 3 , 4 , 2 ] B = [ 2 , 4 , 4 , 4 , 6 , 8 ] write ( * , g ) 'A=' , A write ( * , g ) 'B=' , B write ( * , g ) ismember ( A , B ) end program demo_ismember","tags":"","url":"program/demo_ismember.html"},{"title":"demo_issorted.f90 – M_sets","text":"Source Code program demo_issorted use M_sets , only : issorted character ( len =* ), parameter :: g = '(*(g0,1x))' integer , allocatable :: A (:) write ( * , g ) 'ISSORTED' , 'Find the issorted elements of vector A.' A = [ 10 , - 10 , 0 , 1 , 2 , 3 , 3 , 2 , 1 , - 10 ] write ( * , g ) 'A=' , A write ( * , g ) issorted ( A ) A = [ - 10 , 10 , 100 , 201 ] write ( * , g ) 'A=' , A write ( * , g ) issorted ( A ) end program demo_issorted","tags":"","url":"sourcefile/demo_issorted.f90.html"},{"title":"demo_bool.f90 – M_sets","text":"Source Code program demo_bool use M_sets , only : bool implicit none write ( * , * ) 'is 10 < 20 ?' , bool ( 10 < 20 ) write ( * , * ) 'elemental' , bool ([ 2 > 1 , 3 == 4 , 10 < 5 , 100 > 50 ]) if ( sum ( bool ([ 2 > 1 , 3 == 4 , 10 < 5 , 100 > 50 ])) >= 2 ) then write ( * , * ) 'two or more are true' endif end program demo_bool","tags":"","url":"sourcefile/demo_bool.f90.html"},{"title":"M_sets.F90 – M_sets","text":"Source Code module M_sets !> !!##NAME !!    M_sets(3f) - [M_sets::INTRO] functions reminiscent of Matlab set !!    functions !! !!##SYNOPSIS !! !!    Procedure names and syntax: !! !!     use M_sets, only : & !!     & union, unique, intersect, setdiff, ismember, setxor !!     use M_sets, only : & !!     & issorted, isequal, bool !! !!##DESCRIPTION !! !! Set operations compare the elements in two sets to find commonalities !! or differences. This includes Unions, Intersections, and Membership. !! !! M_set(3f) is a Fortran module comprising a small subset of set theory !! functions reminiscent of Matlab functions. !! !! The functions currently support vectors of integer, default character, !! and default real and doubleprecision type. !! !! float numbers (both kind=real32 and kind=real64) are allowed but \"caveat !! emptor\", as comparing floats for equality has issues. You may have to !! condition the float data by converting it to scaled integers or using !! intrinsics such as NEAREST(3f) to produce the desired results. !! !! M_set(3f) primarily uses simple calls to the M_orderpack(3f) module to !! provide the functionality. The functions are not otherwise tuned for !! performance and make loose use of memory allocation but are sufficient !! for most uses, simple to use, and familiar to a large base of users. !! !! ## Functions !!  + union(A,B,setOrder)     - Join two sets and remove duplicates of values !!  + unique(A,setOrder)      - Remove duplicates of values from a set !!  + intersect(A,B,setOrder) - Find the values common to both A and B !!  + setdiff(A,B,setOrder)   - Find the values in A that are not in B !!  + ismember(A,B,setOrder)  - Create a mask of A marking elements also in B !!  + setxor(A,B,setOrder)    - Find values of A and B not in both arrays !!  + issorted(A)             - Determine if array is already sorted !!  + isequal(A,B)             -Determine if two sets are equal with a tolerance !!  + bool(expr)              - 1 if logical expression is true, 0 if false. !! !!  The subsequent data may be produced sorted, or left in the order !!  encountered. !! !!##EXAMPLES !! !! !!  sample program: !! !!    program demo_M_sets !!    use M_sets, only: & !!    & unique, intersect, union, setdiff, setxor, bool, & !!    & ismember, issorted, isequal !!    character(len=*),parameter :: all='(*(g0,1x))' !!    character(len=*),parameter :: nl=new_line('A') !!    integer, allocatable      :: A(:) !!    integer, allocatable      :: B(:) !!    integer, allocatable      :: C(:) !! !!       A = [10, -10, 0, 1, 2, 3, 3, 2, 1, -10] !!       ! !!       print all                                                   ,nl, & !!       'UNIQUE','Find the unique elements of vector A.'            ,nl, & !!       'A=', A                                                     ,nl, & !!       'sorted=',unique(A)                                         ,nl, & !!       'stable=',unique(A, setOrder='stable') !! !!       A=[5, 7, 1] !!       B=[3, 1, 1] !!       ! !!       print all                                                   ,nl, & !!       'UNION', 'Find the union of vectors A and B.'               ,nl, & !!       'A=', A                                                     ,nl, & !!       'B=', B                                                     ,nl, & !!       'sorted=',union(A, B, 'sorted')                             ,nl, & !!       'stable=',union(A, B, 'stable') !! !!       A=[7, 1, 7, 7, 4] !!       B=[7, 0, 4, 4, 0] !!       ! !!       print all                                                   ,nl, & !!       'INTERSECT', 'Find the values common to both A and B.'      ,nl, & !!       'A=', A                                                     ,nl, & !!       'B=', B                                                     ,nl, & !!       'sorted=',intersect(A, B)                                   ,nl, & !!       'stable=',intersect(A, B, setOrder='stable') !! !!       A=[3, 6, 2, 1, 5, 1, 1] !!       B=[2, 4, 6] !!       ! !!       print all                                                   ,nl, & !!       'SETDIFF','Find the values in A that are not in B.'         ,nl, & !!       'A=', A                                                     ,nl, & !!       'B=', B                                                     ,nl, & !!       'sorted=',setdiff(A, B, 'sorted')                           ,nl, & !!       'stable=',setdiff(A, B, 'stable') !! !!       A=[5,3,4,2] !!       B=[2,4,4,4,6,8] !!       ! !!       print all                                                   ,nl, & !!       'ISMEMBER','Determine which elements of A are also in B.'   ,nl, & !!       'A=', A                                                     ,nl, & !!       'B=', B                                                     ,nl, & !!       'in A and B=',ismember(A,B) !! !!       A=[5,1,3,3,3] !!       B=[4,1,2] !!       ! !!       print all                                                   ,nl, & !!       'SETXOR'                                                       , & !!       'Find values of A and B not in their intersection.'         ,nl, & !!       'A=', A                                                     ,nl, & !!       'B=', B                                                     ,nl, & !!       'sorted=',setxor(A,B)                                       ,nl, & !!       'stable=',setxor(A,B,'stable') !! !!       A=[1,2,3,4,5] !!       B=[5,4,3,2,1] !!       ! !!       print all                                                   ,nl, & !!       'ISSSORTED'                                                    , & !!       'confirm whether array is sorted in ascending order or not' ,nl, & !!       'A=', A                                                     ,nl, & !!       'B=', B                                                     ,nl, & !!       'is A sorted?',issorted(A)                                  ,nl, & !!       'is B sorted?',issorted(B) !! !!       A=[1,2,3,4,5] !!       B=[1,2,3,4,5] !!       ! !!       print all                                                   ,nl, & !!       'ISEQUAL'                                                     , & !!       'confirm whether sets have same elements in same order    ' ,nl, & !!       'A=', A                                                     ,nl, & !!       'B=', B                                                     ,nl, & !!       'is A equal to B?',isequal(A,B)                             ,nl, & !!       'is B equal to -B?',isequal(A,-B) !! !!       A=[1,2,3,4,5] !!       B=[5,2,3,4,1] !!       ! !!       print all                                                   ,nl, & !!       'BOOL'                                                         , & !!       'if logical expression is true, 0 if false.'                ,nl, & !!       'A=', A                                                     ,nl, & !!       'B=', B                                                     ,nl, & !!       'is A(i) = B(i) ?',bool(A==B)                               ,nl, & !!       'how many elements are the same?',sum(bool(A==B)) !! !!    end program demo_M_sets !! !! Results: !! !!  > !!  >  UNIQUE Find the unique elements of vector A. !!  >  A= 10 -10 0 1 2 3 3 2 1 -10 !!  >  sorted= -10 0 1 2 3 10 !!  >  stable= 10 -10 0 1 2 3 !!  > !!  >  UNION Find the union of vectors A and B. !!  >  A= 5 7 1 !!  >  B= 3 1 1 !!  >  sorted= 1 3 5 7 !!  >  stable= 5 7 1 3 !!  > !!  >  INTERSECT Find the values common to both A and B. !!  >  A= 7 1 7 7 4 !!  >  B= 7 0 4 4 0 !!  >  sorted= 4 7 !!  >  stable= 7 4 !!  > !!  >  SETDIFF Find the values in A that are not in B. !!  >  A= 3 6 2 1 5 1 1 !!  >  B= 2 4 6 !!  >  sorted= 1 3 5 !!  >  stable= 3 1 5 !!  > !!  >  ISMEMBER Determine which elements of A are also in B. !!  >  A= 5 3 4 2 !!  >  B= 2 4 4 4 6 8 !!  >  in A and B= 0 0 1 1 !!  > !!  >  SETXOR Find values of A and B not in their intersection. !!  >  A= 5 1 3 3 3 !!  >  B= 4 1 2 !!  >  sorted= 2 3 4 5 !!  >  stable= 5 3 4 2 !!  > !!  >  ISSSORTED confirm whether array is sorted in ascending order or not !!  >  A= 1 2 3 4 5 !!  >  B= 5 4 3 2 1 !!  >  is A sorted? 1 !!  >  is B sorted? 0 !!  > !!  >  BOOL if logical expression is true, 0 if false. !!  >  A= 1 2 3 4 5 !!  >  B= 5 2 3 4 1 !!  >  is A(i) = B(i) ? 0 1 1 1 0 !!  >  how many elements are the same? 3 !! !!##AUTHORS !!    John S. Urban, 2023-07-20 !! !!##LICENSE !!    CC0-1.0 ! a subset of the functionality of set functions in Matlab are provided. use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 use M_orderpack , only : unique_ => unique , occurrences_ => occurrences , sort_ => sort use M_orderpack , only : rank_unique_ => rank_unique private public :: unique ! C = unique(A,setOrder)        returns the same data as in A, but with no repetitions. public :: union ! C = union(A,B,setOrder)       returns the combined data from A and B with no repetitions. public :: intersect ! C = intersect(A,B,setOrder)   returns the data common to both A and B, with no repetitions. public :: setdiff ! C = setdiff(A,B,setOrder)     returns the data in A that is not in B, with no repetitions. public :: ismember ! C = ismember(A,B) returns     an array containing 1 (true) where the data in A is found in B. Elsewhere, 0. public :: setxor ! C = setxor(A,B,setOrder)      returns the data of A and B that are not in their intersection !                               (the symmetric difference), with no repetitions. That is, setxor returns the !                               data that occurs in A or B, but not both. C is in sorted order. public :: issorted ! C = issorted(A)               determine if A is in ascending order or not public :: isequal ! C = isequal(A,B,tolerance)    determine if set A has same element values in same order as B to !                               within a tolerance public :: bool ! C = bool(logical_expression)  1 if logical expression is true, 0 if false. interface unique ; module procedure unique_c ; end interface unique interface union ; module procedure union_c ; end interface union interface intersect ; module procedure intersect_c ; end interface intersect interface setdiff ; module procedure setdiff_c ; end interface setdiff interface ismember ; module procedure ismember_c ; end interface ismember interface setxor ; module procedure setxor_c ; end interface setxor interface issorted ; module procedure issorted_c ; end interface issorted interface isequal ; module procedure isequal_c ; end interface isequal interface unique ; module procedure unique_int8 ; end interface unique interface union ; module procedure union_int8 ; end interface union interface intersect ; module procedure intersect_int8 ; end interface intersect interface setdiff ; module procedure setdiff_int8 ; end interface setdiff interface ismember ; module procedure ismember_int8 ; end interface ismember interface setxor ; module procedure setxor_int8 ; end interface setxor interface issorted ; module procedure issorted_int8 ; end interface issorted interface isequal ; module procedure isequal_int8 ; end interface isequal interface unique ; module procedure unique_int16 ; end interface unique interface union ; module procedure union_int16 ; end interface union interface intersect ; module procedure intersect_int16 ; end interface intersect interface setdiff ; module procedure setdiff_int16 ; end interface setdiff interface ismember ; module procedure ismember_int16 ; end interface ismember interface setxor ; module procedure setxor_int16 ; end interface setxor interface issorted ; module procedure issorted_int16 ; end interface issorted interface isequal ; module procedure isequal_int16 ; end interface isequal interface unique ; module procedure unique_int32 ; end interface unique interface union ; module procedure union_int32 ; end interface union interface intersect ; module procedure intersect_int32 ; end interface intersect interface setdiff ; module procedure setdiff_int32 ; end interface setdiff interface ismember ; module procedure ismember_int32 ; end interface ismember interface setxor ; module procedure setxor_int32 ; end interface setxor interface issorted ; module procedure issorted_int32 ; end interface issorted interface isequal ; module procedure isequal_int32 ; end interface isequal interface unique ; module procedure unique_int64 ; end interface unique interface union ; module procedure union_int64 ; end interface union interface intersect ; module procedure intersect_int64 ; end interface intersect interface setdiff ; module procedure setdiff_int64 ; end interface setdiff interface ismember ; module procedure ismember_int64 ; end interface ismember interface setxor ; module procedure setxor_int64 ; end interface setxor interface issorted ; module procedure issorted_int64 ; end interface issorted interface isequal ; module procedure isequal_int64 ; end interface isequal interface unique ; module procedure unique_real32 ; end interface unique interface union ; module procedure union_real32 ; end interface union interface intersect ; module procedure intersect_real32 ; end interface intersect interface setdiff ; module procedure setdiff_real32 ; end interface setdiff interface ismember ; module procedure ismember_real32 ; end interface ismember interface setxor ; module procedure setxor_real32 ; end interface setxor interface issorted ; module procedure issorted_real32 ; end interface issorted interface isequal ; module procedure isequal_real32 ; end interface isequal interface unique ; module procedure unique_real64 ; end interface unique interface union ; module procedure union_real64 ; end interface union interface intersect ; module procedure intersect_real64 ; end interface intersect interface setdiff ; module procedure setdiff_real64 ; end interface setdiff interface ismember ; module procedure ismember_real64 ; end interface ismember interface setxor ; module procedure setxor_real64 ; end interface setxor interface issorted ; module procedure issorted_real64 ; end interface issorted interface isequal ; module procedure isequal_real64 ; end interface isequal interface bool module procedure :: bool_expr module procedure :: bool_int8 , bool_int16 , bool_int32 , bool_int64 module procedure :: bool_float32 , bool_float64 module procedure :: bool_complex32 , bool_complex64 module procedure :: bool_char end interface bool contains !> !!##NAME !!    unique(3f) - [M_sets] return unique values in array A !! !!##SYNOPSIS !! !! !!    unique(A,setOrder) !! !!##DESCRIPTION !! !! unique(3) returns the unique values found in an array. That is, it !! eliminates all but one occurrence of each value. !! !! The result is in sorted order by default, but may be returned in the !! order found. !! !!##OPTIONS !! !!     A         input array to extract unique values from !!     setOrder  May be \"sort\" or \"stable\". If \"stable\" the values are !!               returned in the order discovered. The default is !!               \"sorted\", which returns the data in ascending order. !! !!##RETURNS !! !!     All the values that occur in the input occur in the output !!     just once. All duplicates are removed. !! !!##EXAMPLES !! !! !!  sample program: !! !!    program demo_unique !!    use M_sets, only: unique !!    character(len=*),parameter :: g='(*(g0,1x))' !!    integer,allocatable        :: A(:) !! !!       write(*,g) 'UNIQUE','Find the unique elements of vector A.' !!        A = [10, -10, 0, 1, 2, 3, 3, 2, 1, -10] !!        write(*,g) 'A=', A !!        write(*,g) unique(A) !!        write(*,g) unique(A, setOrder='stable') !! !!    end program demo_unique !! !! Results: !! !!  > UNIQUE Find the unique elements of vector A. !!  > A= 10 -10 0 1 2 3 3 2 1 -10 !!  > -10 0 1 2 3 10 !!  > 10 -10 0 1 2 3 !! !!##AUTHORS !!    John S. Urban, 2023-07-20 !! !!##LICENSE !!    CC0-1.0 !----------------------------------------------------------------------------------------------------------------------------------- function unique_c ( A , setOrder ) result ( answer ) ! C = unique(A) returns the same data as in A, but with no repetitions. C is in sorted order. character ( len =* ), intent ( in ) :: A (:) character ( len =* ), intent ( in ), optional :: setOrder character ( len = :), allocatable :: answer (:) character ( len = :), allocatable :: setOrder_ integer :: nuni if ( present ( setOrder )) then setOrder_ = setOrder else setOrder_ = 'sorted' endif answer = A call unique_ ( answer , nuni ) answer = answer (: nuni ) select case ( lower ( setOrder_ )) case ( 'stable' ) case ( 'sorted' ) call sort_ ( answer ) case default stop '*unique* unknown setOrder ' // setOrder_ // ' allowed are \"stable\" and \"sorted\"' end select end function unique_c !> !!##NAME !!    union(3f) - [M_sets] Join two sets and removes duplicates of values !! !!##SYNOPSIS !! !! !!    union(A,B, setOrder) !! !!##DESCRIPTION !! !! The two sets are combined and repetitions are removed. !! !!##OPTIONS !! !!     A         input array !!     B         input array !!     setOrder  May be \"sort\" or \"stable\". If \"stable\" the values are !!               returned in the order discovered. The default is !!               \"sorted\", which returns the data in ascending order. !! !!##EXAMPLES !! !! !!  sample program: !! !!    program demo_union !!    use M_sets, only: union !!    character(len=*),parameter :: g='(*(g0,1x))' !!    integer,allocatable        :: A(:) !!    integer,allocatable        :: B(:) !! !!       write(*,g) 'UNION', 'Find the union of vectors A and B.' !!       A=[5, 7, 1] !!       B=[3, 1, 1] !!       write(*,g) 'A=', A !!       write(*,g) 'B=', B !!       write(*,g) union(A,B) !! !!       A=[5, 5, 3] !!       B=[1, 2, 5] !!       write(*,g) 'A=', A !!       write(*,g) 'B=', B !!       write(*,g) union(A, B, 'sorted') !!       write(*,g) union(A, B, 'stable') !! !!    end program demo_union !! ``` !! Results: !! !!  > UNION Find the union of vectors A and B. !!  > A= 5 7 1 !!  > B= 3 1 1 !!  > 1 3 5 7 !!  > A= 5 5 3 !!  > B= 1 2 5 !!  > 1 2 3 5 !!  > 5 3 1 2 !! !!##AUTHORS !!    John S. Urban, 2023-07-20 !! !!##LICENSE !!    CC0-1.0 !----------------------------------------------------------------------------------------------------------------------------------- function union_c ( A , B , setOrder ) result ( answer ) ! C = union(A,B) returns the combined data from A and B with no repetitions. C is in sorted order. character ( len =* ), intent ( in ) :: A (:) character ( len =* ), intent ( in ) :: B (:) character ( len =* ), intent ( in ), optional :: setOrder character ( len = :), allocatable :: answer (:) character ( len = :), allocatable :: kludge (:) integer :: longest longest = max ( len ( a ), len ( b )) kludge = [ character ( len = longest ) :: A , B ] answer = unique ( kludge , setOrder ) end function union_c !> !!##NAME !!    intersect(3f) - [M_sets] Find the values common to both sets A and B !! !!##SYNOPSIS !! !! !!    intersect(A,B, setOrder) !! !!##DESCRIPTION !! !! The values that occur at least once in each set are returned. !! !! That is, intersect(3f) returns the data common to both A and B, with !! no repetitions. !! !!##OPTIONS !! !!     A         input array !!     B         input array !!     setOrder  May be \"sort\" or \"stable\". If \"stable\" the values are !!               returned in the order discovered. The default is !!               \"sorted\", which returns the data in ascending order. !! !!##EXAMPLES !! !! !!  sample program: !! !!   program demo_intersect !!   use M_sets, only: unique, intersect, union, setdiff, ismember, setxor !!   character(len=*),parameter :: g='(*(g0,1x))' !!   integer, allocatable       :: A(:) !!   integer, allocatable       :: B(:) !! !!      write(*,g) 'INTERSECT', 'Find the values common to both A and B.' !!       A=[7, 1, 7, 7, 4] !!       B=[7, 0, 4, 4, 0] !!       write(*,g) 'A=', A !!       write(*,g) 'B=', B !!       write(*,g) intersect(A, B) !!       write(*,g) intersect(A, B, setOrder='stable') !!   end program demo_intersect !! !! Results: !! !!  > INTERSECT Find the values common to both A and B. !!  > A= 7 1 7 7 4 !!  > B= 7 0 4 4 0 !!  > 4 7 !!  > 7 4 !! !!##AUTHORS !!    John S. Urban, 2023-07-20 !! !!##LICENSE !!    CC0-1.0 !----------------------------------------------------------------------------------------------------------------------------------- function intersect_c ( A , B , setOrder ) result ( answer ) ! C = intersect(A,B) returns the data common to both A and B, with no repetitions. C is in sorted order by default character ( len =* ), intent ( in ) :: A (:) character ( len =* ), intent ( in ) :: B (:) character ( len =* ), intent ( in ), optional :: setOrder character ( len = :), allocatable :: answer (:) integer , allocatable :: iwrk (:) character ( len = :), allocatable :: kludge (:) integer :: longest longest = max ( len ( A ), len ( B )) answer = [ character ( len = longest ) :: unique ( A , setOrder ), unique ( B , setOrder )] if ( allocated ( iwrk )) deallocate ( iwrk ) allocate ( iwrk ( size ( answer ))) call occurrences_ ( answer , iwrk ) !-------------------------------- !answer= unique(pack(answer//'',iwrk > 1),setOrder) ! add //' ' to avoid gfortran 13.1.0-8 bug kludge = pack ( answer // '' , iwrk > 1 ) answer = unique ( kludge , setOrder ) !-------------------------------- end function intersect_c !> !!##NAME !!    setdiff(3f) - [M_sets] Find the values in A that are not in B !! !!##SYNOPSIS !! !! !!    setdiff(A,B, setOrder) !! !!##DESCRIPTION !! !! setdiff(3f) returns the data in A that is not in B, with no repetitions. !! !!##OPTIONS !! !!     A         input array !!     B         input array !!     setOrder  May be \"sort\" or \"stable\". If \"stable\" the values are !!               returned in the order discovered. The default is !!               \"sorted\", which returns the data in ascending order. !! !!##EXAMPLES !! !! !!  sample program: !! !!    program demo_setdiff !!    use M_sets, only: setdiff !!    character(len=*),parameter :: g='(*(g0,1x))' !!    integer, allocatable       :: A(:) !!    integer, allocatable       :: B(:) !! !!       write(*,g) 'SETDIFF','Find the values in A that are not in B.' !!        A=[3, 6, 2, 1, 5, 1, 1] !!        B=[2, 4, 6] !!        write(*,g) 'A=', A !!        write(*,g) 'B=', B !!        write(*,g) setdiff(A, B) !!        write(*,g) setdiff([4, 1, 3, 2, 5], [2, 1], 'sorted') !!        write(*,g) setdiff([4, 1, 3, 2, 5], [2, 1], 'stable') !! !!    end program demo_setdiff !! !! Results: !! !!  > SETDIFF Find the values in A that are not in B. !!  > A= 3 6 2 1 5 1 1 !!  > B= 2 4 6 !!  > 1 3 5 !!  > 3 4 5 !!  > 4 3 5 !! !!##AUTHORS !!    John S. Urban, 2023-07-20 !! !!##LICENSE !!    CC0-1.0 !----------------------------------------------------------------------------------------------------------------------------------- function setdiff_c ( A , B , setOrder ) result ( answer ) ! C = setdiff(A,B) returns the data in A that is not in B, with no repetitions. C is in sorted order by default. character ( len =* ), intent ( in ) :: a (:) character ( len =* ), intent ( in ) :: b (:) character ( len =* ), intent ( in ), optional :: setOrder character ( len = :), allocatable :: answer (:), kludge (:) integer , allocatable :: iwrk (:) integer :: longest answer = unique ( b , setOrder = 'stable' ) longest = max ( len ( a ), len ( b )) answer = [ character ( len = longest ) :: unique ( a , setOrder = 'stable' ), answer , answer ] ! potentially a lot of memory if ( allocated ( iwrk )) deallocate ( iwrk ) allocate ( iwrk ( size ( answer ))) call occurrences_ ( answer , iwrk ) !-------------------------------- !answer = unique(pack(answer, iwrk  ==  1), setOrder) kludge = pack ( answer // '' , iwrk == 1 ) answer = unique ( kludge , setOrder ) !-------------------------------- end function setdiff_c !> !!##NAME !!    ismember(3f) - [M_sets] Create a mask of A marking elements also in B !! !!##SYNOPSIS !! !! !!    ismember(A,B) !! !!##DESCRIPTION !! !! Identifies elements of the first set that are members of the second set !! as well. !! !! The returned array is a mask of the first array containing a 1 !! (aka. \"true\") where the data in A is found in B. Elsewhere, the array !! contains 0 (aka. \"false\"). !! !!##OPTIONS !! !!     A         input array !!     B         input array of values to find in vector A. !! !!##RETURNS !!     A mask of array A with a 1 at locations where the value in that !!     position in A is also a value that occurs in B, and with a 0 at !!     locations where that value in A was not found in B. !! !!##EXAMPLES !! !! !!  sample program: !! !!    program demo_ismember !!    use M_sets, only: ismember !!    character(len=*),parameter :: g='(*(g0,1x))' !!    integer, allocatable       :: A(:) !!    integer, allocatable       :: B(:) !! !!       write(*,g) 'ISMEMBER', 'Determine which elements of A are also in B.' !! !!        A=[5,3,4,2] !!        B=[2,4,4,4,6,8] !!        write(*,g) 'A=', A !!        write(*,g) 'B=', B !!        write(*,g) ismember(A,B) !! !!    end program demo_ismember !! !! Results: !! !!  > ISMEMBER Determine which elements of A are also in B. !!  > A= 5 3 4 2 !!  > B= 2 4 4 4 6 8 !!  > 0 0 1 1 !! !!##AUTHORS !!    John S. Urban, 2023-07-20 !! !!##LICENSE !!    CC0-1.0 !----------------------------------------------------------------------------------------------------------------------------------- function ismember_c ( A , B ) result ( answer ) ! C = ismember(A,B) returns an array containing 1 (true) where the data in A is found in B. Elsewhere, the array contains 0 character ( len =* ), intent ( in ) :: a (:) character ( len =* ), intent ( in ) :: b (:) integer , allocatable :: answer (:) integer , allocatable :: iwrk1 (:) integer , allocatable :: iwrk2 (:) character ( len = :), allocatable :: cwrk1 (:) integer :: inums integer :: longest longest = max ( len ( a ), len ( b )) inums = size ( a ) cwrk1 = [ character ( len = longest ) :: a , unique ( b ) ] ! potentially a lot of memory if ( allocated ( iwrk2 )) deallocate ( iwrk2 ) allocate ( iwrk2 ( size ( a ))) if ( allocated ( iwrk1 )) deallocate ( iwrk1 ) allocate ( iwrk1 ( size ( cwrk1 ))) call occurrences_ ( cwrk1 , iwrk1 ) call occurrences_ ( a , iwrk2 ) answer = iwrk1 (: inums ) - iwrk2 answer = merge ( 0 , 1 , answer == 0 ) end function ismember_c !> !!##NAME !!    setxor(3f) - [M_sets] Find values of A and B not in both arrays !! !!##SYNOPSIS !! !! !!    setxor(A,B, setOrder) !! !!##DESCRIPTION !! !! setxfor(3f) returns the exclusive OR of two arrays. That is, it returns !! the data of A and B that are not in their intersection (the symmetric !! difference), with no repetitions. !! !! Another way of defining the result is that setxor(3f) returns the data !! that occurs in A or B, but not both. !! !!##OPTIONS !! !!     A         input array !!     B         input array !!     setOrder  May be \"sort\" or \"stable\". If \"stable\" the values are !!               returned in the order discovered. The default is !!               \"sorted\", which returns the data in ascending order. !! !!##EXAMPLES !! !! !!  sample program: !! !!    program demo_setxor !!    use M_sets, only: setxor !!    character(len=*),parameter :: g='(*(g0,1x))' !!    integer, allocatable       :: A(:) !!    integer, allocatable       :: B(:) !! !!       write(*,g) 'SETXOR','Find values of A and B not in their intersection.' !!       A = [5,1,3,3,3] !!       B = [4,1,2] !!       write(*,g) 'A=', A !!       write(*,g) 'B=', B !!       write(*,g) setxor(A,B) !!       write(*,g) setxor(A,B,'stable') !! !!    end program demo_setxor !! !! Results: !! !!  > SETXOR Find values of A and B not in their intersection. !!  > A= 5 1 3 3 3 !!  > B= 4 1 2 !!  > 2 3 4 5 !!  > 5 3 4 2 !! !!##AUTHORS !!    John S. Urban, 2023-07-20 !! !!##LICENSE !!    CC0-1.0 !----------------------------------------------------------------------------------------------------------------------------------- function setxor_c ( A , B , setOrder ) result ( answer ) ! C = setxor(A,B,setOrder) returns the data of A and B that are not in their intersection !                          (the symmetric difference), with no repetitions. That is, setxor returns the !                          data that occurs in A or B, but not both. C is in sorted order. character ( len =* ), intent ( in ) :: a (:) character ( len =* ), intent ( in ) :: b (:) character ( len =* ), intent ( in ), optional :: setOrder character ( len = :), allocatable :: answer (:), kludge (:) integer , allocatable :: iwrk1 (:) integer , allocatable :: iwrk2 (:) integer , allocatable :: iwrk3 (:) integer :: inums integer :: longest inums = size ( a ) longest = max ( len ( a ), len ( b )) answer = [ character ( len = longest ) :: a , b ] ! potentially a lot of memory if ( allocated ( iwrk1 )) deallocate ( iwrk1 ) allocate ( iwrk1 ( size ( answer ))) call occurrences_ ( answer , iwrk1 ) if ( allocated ( iwrk2 )) deallocate ( iwrk2 ) allocate ( iwrk2 ( size ( a ))) call occurrences_ ( a , iwrk2 ) if ( allocated ( iwrk3 )) deallocate ( iwrk3 ) allocate ( iwrk3 ( size ( b ))) call occurrences_ ( b , iwrk3 ) iwrk1 = iwrk1 - [ iwrk2 , iwrk3 ] kludge = pack ( answer // '' , iwrk1 == 0 ) answer = unique ( kludge , setOrder ) end function setxor_c !> !!##NAME !!    isequal(3f) - [M_sets] Report if vector A is equal to vector B !! !!##SYNOPSIS !! !! !!    isequal(A,B,TOLERANCE) !! !!      character(len=:)intent(in) :: A,B !!        or !!      integer|real|complex(in) :: A,B !!      real,optional            :: TOLERANCE !! !!##DESCRIPTION !! !!    Report if A is equal to B. Equality is defined as the same element !!    values in the same order. !! !!    A 1 (true) is returned when the elements of A have a one-to-one !!    correspondence to the elements of B with the same values in the !!    same order.  0 (false) is returned otherwise. !! !!##OPTIONS !! !!     A          input array to compare against !!     B          input array to compare to A !!     TOLERANCE  for numeric values consider the corresponding elements !!                of A and B equal if they are equal within the specified !!                tolerance. !! !!     A,B and TOLERANCE are of the same type and kind. !! !!##RETURNS !! !!     1 if input array A is to array B, 0 otherwise !! !!##EXAMPLES !! !! !!  sample program: !! !!    program demo_isequal !!    use M_sets, only: isequal !!    character(len=*),parameter :: g='(*(g0,1x))' !!    integer,allocatable        :: A(:) !!    integer,allocatable        :: B(:) !! !!    write(*,g) 'isequal','Find if A is equal to B. ' !!        A = [10, -10, 0, 1, 2, 3, 3, 2, 1,-10] !!        B = [10, -10, 0, 1, 2, 3, 3, 2, 1, 10] !!        write(*,g) 'A=', A !!        write(*,g) 'B=', B !!        write(*,g) isequal(A,B) !!    write(*,g) 'isequal','Find if A is equal to A. ' !!        write(*,g) isequal(A,A) !! !!    end program demo_isequal !! !! Results: !! !!  > isequal Find the isequal elements of vector A. !!  > A= 10 -10 0 1 2 3 3 2 1 -10 !!  > 0 !!  > A= -10 10 100 201 !!  > 1 !! !!##AUTHORS !!    John S. Urban, 2023-07-20 !! !!##LICENSE !!    CC0-1.0 !----------------------------------------------------------------------------------------------------------------------------------- function isequal_c ( A , B ) result ( answer ) ! TF = isequal(A) returns the logical scalar 1 (true) when the elements of A are listed in ascending order and 0 (false) otherwise. character ( len =* ), intent ( in ) :: A (:) character ( len =* ), intent ( in ) :: B (:) integer :: answer integer :: i answer = 1 if ( size ( A ). eq . size ( B )) then ! A merge() might not short-circuit or make copies? do i = 1 , size ( A ) if ( A ( i ) /= B ( i )) then answer = 0 exit endif enddo else answer = 0 endif end function isequal_c !> !!##NAME !!    issorted(3f) - [M_sets] Report if A is sorted in ascending order or not. !! !!##SYNOPSIS !! !! !!    issorted(A) !! !!      character(len=:)intent(in) :: A !!        or !!      integer|real|complex(in) :: A !! !!##DESCRIPTION !! !!    Report if A is sorted in ascending order or not. A 1 (true) is !!    returned when the elements of A are listed in ascending order and 0 !!    (false) otherwise. !! !!##OPTIONS !! !!     A         input array to test !! !!##RETURNS !! !!     1 if input array A is sorted in ascending order, 0 otherwise !! !!##EXAMPLES !! !! !!  sample program: !! !!    program demo_issorted !!    use M_sets, only: issorted !!    character(len=*),parameter :: g='(*(g0,1x))' !!    integer,allocatable        :: A(:) !! !!       write(*,g) 'ISSORTED','Find the issorted elements of vector A.' !!        A = [10, -10, 0, 1, 2, 3, 3, 2, 1, -10] !!        write(*,g) 'A=', A !!        write(*,g) issorted(A) !!        A = [-10, 10, 100, 201] !!        write(*,g) 'A=', A !!        write(*,g) issorted(A) !! !!    end program demo_issorted !! !! Results: !! !!  > ISSORTED Find the issorted elements of vector A. !!  > A= 10 -10 0 1 2 3 3 2 1 -10 !!  > 0 !!  > A= -10 10 100 201 !!  > 1 !! !!##AUTHORS !!    John S. Urban, 2023-07-20 !! !!##LICENSE !!    CC0-1.0 !----------------------------------------------------------------------------------------------------------------------------------- function issorted_c ( A ) result ( answer ) ! TF = issorted(A) returns the logical scalar 1 (true) when the elements of A are listed in ascending order and 0 (false) otherwise. character ( len =* ), intent ( in ) :: A (:) integer :: answer integer :: i answer = 1 do i = 1 , size ( a ) - 1 if ( A ( i ) > A ( i + 1 )) then answer = 0 exit endif enddo end function issorted_c elemental pure function lower ( str ) result ( string ) ! ident_1=\"@(#) M_strings lower(3f) Changes a string to lowercase\" character ( * ), intent ( in ) :: str character ( len ( str )) :: string integer :: i integer , parameter :: diff = iachar ( 'A' ) - iachar ( 'a' ) string = str do concurrent ( i = 1 : len_trim ( str )) ! step thru each letter in the string in specified range select case ( str ( i : i )) case ( 'A' : 'Z' ) string ( i : i ) = achar ( iachar ( str ( i : i )) - diff ) ! change letter to miniscule case default end select enddo end function lower function unique_int8 ( A , setOrder ) result ( answer ) ! C = unique(A) returns the same data as in A, but with no repetitions. C is in sorted order. integer ( kind = int8 ), intent ( in ) :: A (:) character ( len =* ), intent ( in ), optional :: setOrder integer ( kind = int8 ), allocatable :: answer (:) integer , allocatable :: indices (:) character ( len = :), allocatable :: setOrder_ integer :: nuni if ( present ( setOrder )) then setOrder_ = setOrder else setOrder_ = 'sorted' endif answer = A select case ( lower ( setOrder_ )) case ( 'stable' ) call unique_ ( answer , nuni ) answer = answer (: nuni ) case ( 'sorted' ) if ( allocated ( indices )) deallocate ( indices ) allocate ( indices ( size ( A ))) call rank_unique_ ( A , indices , nuni ) answer = A ( indices (: nuni )) case default stop '*unique* unknown setOrder ' // setOrder_ // 'allowed are \"stable\" and \"sorted\"' end select end function unique_int8 function union_int8 ( A , B , setOrder ) result ( answer ) ! C = union(A,B) returns the combined data from A and B with no repetitions. C is in sorted order. integer ( kind = int8 ), intent ( in ) :: A (:) integer ( kind = int8 ), intent ( in ) :: B (:) character ( len =* ), intent ( in ), optional :: setOrder integer ( kind = int8 ), allocatable :: answer (:) answer = unique ([ A , B ], setOrder ) end function union_int8 function intersect_int8 ( A , B , setOrder ) result ( answer ) ! C = intersect(A,B) returns the data common to both A and B, with no repetitions. C is in sorted order by default integer ( kind = int8 ), intent ( in ) :: A (:) integer ( kind = int8 ), intent ( in ) :: B (:) character ( len =* ), intent ( in ), optional :: setOrder integer ( kind = int8 ), allocatable :: answer (:) integer , allocatable :: iwrk (:) answer = [ unique ( A , setOrder ), unique ( B , setOrder )] if ( allocated ( iwrk )) deallocate ( iwrk ) allocate ( iwrk ( size ( answer ))) call occurrences_ ( answer , iwrk ) answer = unique ( pack ( answer , iwrk > 1 ), setOrder ) end function intersect_int8 function setdiff_int8 ( A , B , setOrder ) result ( answer ) ! C = setdiff(A,B) returns the data in A that is not in B, with no repetitions. C is in sorted order by default. integer ( kind = int8 ), intent ( in ) :: a (:) integer ( kind = int8 ), intent ( in ) :: b (:) character ( len =* ), intent ( in ), optional :: setOrder integer ( kind = int8 ), allocatable :: answer (:) integer , allocatable :: iwrk (:) answer = unique ( b , setOrder = 'stable' ) answer = [ unique ( a , setOrder = 'stable' ), answer , answer ] ! potentially a lot of memory if ( allocated ( iwrk )) deallocate ( iwrk ) allocate ( iwrk ( size ( answer ))) call occurrences_ ( answer , iwrk ) answer = unique ( pack ( answer , iwrk == 1 ), setOrder ) end function setdiff_int8 function ismember_int8 ( A , B ) result ( answer ) ! C = ismember(A,B) returns an array containing 1 (true) where the data in A is found in B. Elsewhere, the array contains 0 integer ( kind = int8 ), intent ( in ) :: a (:) integer ( kind = int8 ), intent ( in ) :: b (:) integer ( kind = int8 ), allocatable :: ab (:) integer , allocatable :: answer (:) integer , allocatable :: iwrk1 (:) integer , allocatable :: iwrk2 (:) integer :: inums inums = size ( a ) ab = [ a , unique ( b ) ] ! potentially a lot of memory if ( allocated ( iwrk2 )) deallocate ( iwrk2 ) allocate ( iwrk2 ( size ( a ))) if ( allocated ( iwrk1 )) deallocate ( iwrk1 ) allocate ( iwrk1 ( size ( ab ))) call occurrences_ ( ab , iwrk1 ) call occurrences_ ( a , iwrk2 ) answer = iwrk1 (: inums ) - iwrk2 answer = merge ( 0 , 1 , answer == 0 ) end function ismember_int8 function setxor_int8 ( A , B , setOrder ) result ( answer ) ! C = setxor(A,B,setOrder) returns the data of A and B that are not in their intersection !                          (the symmetric difference), with no repetitions. That is, setxor returns the !                          data that occurs in A or B, but not both. C is in sorted order. integer ( kind = int8 ), intent ( in ) :: a (:) integer ( kind = int8 ), intent ( in ) :: b (:) character ( len =* ), intent ( in ), optional :: setOrder integer ( kind = int8 ), allocatable :: answer (:) integer , allocatable :: iwrk1 (:) integer , allocatable :: iwrk2 (:) integer , allocatable :: iwrk3 (:) integer :: inums inums = size ( a ) answer = [ a , b ] ! potentially a lot of memory if ( allocated ( iwrk1 )) deallocate ( iwrk1 ) allocate ( iwrk1 ( size ( answer ))) call occurrences_ ( answer , iwrk1 ) if ( allocated ( iwrk2 )) deallocate ( iwrk2 ) allocate ( iwrk2 ( size ( a ))) call occurrences_ ( a , iwrk2 ) if ( allocated ( iwrk3 )) deallocate ( iwrk3 ) allocate ( iwrk3 ( size ( b ))) call occurrences_ ( b , iwrk3 ) iwrk1 = iwrk1 - [ iwrk2 , iwrk3 ] answer = pack ( answer , iwrk1 == 0 ) answer = unique ( answer , setOrder ) end function setxor_int8 function issorted_int8 ( A ) result ( answer ) ! TF = issorted(A) returns the logical scalar 1 (true) when the elements of A are listed in ascending order and 0 (false) otherwise. integer ( kind = int8 ), intent ( in ) :: A (:) integer :: answer integer :: i answer = 1 do i = 1 , size ( a ) - 1 if ( A ( i ) > A ( i + 1 )) then answer = 0 exit endif enddo end function issorted_int8 function isequal_int8 ( A , B , TOLERANCE ) result ( answer ) ! TF = isequal(A) returns the logical scalar 1 (true) when the elements of A are identical to elementsof B or  0 (false) otherwise. integer ( kind = int8 ), intent ( in ) :: A (:) integer ( kind = int8 ), intent ( in ) :: B (:) integer ( kind = int8 ), intent ( in ), optional :: TOLERANCE integer ( kind = int8 ) :: DELTA integer :: answer integer :: i answer = 1 if ( present ( tolerance )) then delta = tolerance else delta = 0 endif if ( size ( A ). eq . size ( B )) then ! A merge() might not short-circuit or make copies? if ( delta . eq . 0 ) then do i = 1 , size ( A ) if ( A ( i ) /= B ( i )) then answer = 0 exit endif enddo else do i = 1 , size ( A ) if ( abs ( A ( i ) - B ( i )). gt . delta ) then answer = 0 exit endif enddo endif else answer = 0 endif end function isequal_int8 function unique_int16 ( A , setOrder ) result ( answer ) ! C = unique(A) returns the same data as in A, but with no repetitions. C is in sorted order. integer ( kind = int16 ), intent ( in ) :: A (:) character ( len =* ), intent ( in ), optional :: setOrder integer ( kind = int16 ), allocatable :: answer (:) integer , allocatable :: indices (:) character ( len = :), allocatable :: setOrder_ integer :: nuni if ( present ( setOrder )) then setOrder_ = setOrder else setOrder_ = 'sorted' endif answer = A select case ( lower ( setOrder_ )) case ( 'stable' ) call unique_ ( answer , nuni ) answer = answer (: nuni ) case ( 'sorted' ) if ( allocated ( indices )) deallocate ( indices ) allocate ( indices ( size ( A ))) call rank_unique_ ( A , indices , nuni ) answer = A ( indices (: nuni )) case default stop '*unique* unknown setOrder ' // setOrder_ // 'allowed are \"stable\" and \"sorted\"' end select end function unique_int16 function union_int16 ( A , B , setOrder ) result ( answer ) ! C = union(A,B) returns the combined data from A and B with no repetitions. C is in sorted order. integer ( kind = int16 ), intent ( in ) :: A (:) integer ( kind = int16 ), intent ( in ) :: B (:) character ( len =* ), intent ( in ), optional :: setOrder integer ( kind = int16 ), allocatable :: answer (:) answer = unique ([ A , B ], setOrder ) end function union_int16 function intersect_int16 ( A , B , setOrder ) result ( answer ) ! C = intersect(A,B) returns the data common to both A and B, with no repetitions. C is in sorted order by default integer ( kind = int16 ), intent ( in ) :: A (:) integer ( kind = int16 ), intent ( in ) :: B (:) character ( len =* ), intent ( in ), optional :: setOrder integer ( kind = int16 ), allocatable :: answer (:) integer , allocatable :: iwrk (:) answer = [ unique ( A , setOrder ), unique ( B , setOrder )] if ( allocated ( iwrk )) deallocate ( iwrk ) allocate ( iwrk ( size ( answer ))) call occurrences_ ( answer , iwrk ) answer = unique ( pack ( answer , iwrk > 1 ), setOrder ) end function intersect_int16 function setdiff_int16 ( A , B , setOrder ) result ( answer ) ! C = setdiff(A,B) returns the data in A that is not in B, with no repetitions. C is in sorted order by default. integer ( kind = int16 ), intent ( in ) :: a (:) integer ( kind = int16 ), intent ( in ) :: b (:) character ( len =* ), intent ( in ), optional :: setOrder integer ( kind = int16 ), allocatable :: answer (:) integer , allocatable :: iwrk (:) answer = unique ( b , setOrder = 'stable' ) answer = [ unique ( a , setOrder = 'stable' ), answer , answer ] ! potentially a lot of memory if ( allocated ( iwrk )) deallocate ( iwrk ) allocate ( iwrk ( size ( answer ))) call occurrences_ ( answer , iwrk ) answer = unique ( pack ( answer , iwrk == 1 ), setOrder ) end function setdiff_int16 function ismember_int16 ( A , B ) result ( answer ) ! C = ismember(A,B) returns an array containing 1 (true) where the data in A is found in B. Elsewhere, the array contains 0 integer ( kind = int16 ), intent ( in ) :: a (:) integer ( kind = int16 ), intent ( in ) :: b (:) integer ( kind = int16 ), allocatable :: ab (:) integer , allocatable :: answer (:) integer , allocatable :: iwrk1 (:) integer , allocatable :: iwrk2 (:) integer :: inums inums = size ( a ) ab = [ a , unique ( b ) ] ! potentially a lot of memory if ( allocated ( iwrk2 )) deallocate ( iwrk2 ) allocate ( iwrk2 ( size ( a ))) if ( allocated ( iwrk1 )) deallocate ( iwrk1 ) allocate ( iwrk1 ( size ( ab ))) call occurrences_ ( ab , iwrk1 ) call occurrences_ ( a , iwrk2 ) answer = iwrk1 (: inums ) - iwrk2 answer = merge ( 0 , 1 , answer == 0 ) end function ismember_int16 function setxor_int16 ( A , B , setOrder ) result ( answer ) ! C = setxor(A,B,setOrder) returns the data of A and B that are not in their intersection !                          (the symmetric difference), with no repetitions. That is, setxor returns the !                          data that occurs in A or B, but not both. C is in sorted order. integer ( kind = int16 ), intent ( in ) :: a (:) integer ( kind = int16 ), intent ( in ) :: b (:) character ( len =* ), intent ( in ), optional :: setOrder integer ( kind = int16 ), allocatable :: answer (:) integer , allocatable :: iwrk1 (:) integer , allocatable :: iwrk2 (:) integer , allocatable :: iwrk3 (:) integer :: inums inums = size ( a ) answer = [ a , b ] ! potentially a lot of memory if ( allocated ( iwrk1 )) deallocate ( iwrk1 ) allocate ( iwrk1 ( size ( answer ))) call occurrences_ ( answer , iwrk1 ) if ( allocated ( iwrk2 )) deallocate ( iwrk2 ) allocate ( iwrk2 ( size ( a ))) call occurrences_ ( a , iwrk2 ) if ( allocated ( iwrk3 )) deallocate ( iwrk3 ) allocate ( iwrk3 ( size ( b ))) call occurrences_ ( b , iwrk3 ) iwrk1 = iwrk1 - [ iwrk2 , iwrk3 ] answer = pack ( answer , iwrk1 == 0 ) answer = unique ( answer , setOrder ) end function setxor_int16 function issorted_int16 ( A ) result ( answer ) ! TF = issorted(A) returns the logical scalar 1 (true) when the elements of A are listed in ascending order and 0 (false) otherwise. integer ( kind = int16 ), intent ( in ) :: A (:) integer :: answer integer :: i answer = 1 do i = 1 , size ( a ) - 1 if ( A ( i ) > A ( i + 1 )) then answer = 0 exit endif enddo end function issorted_int16 function isequal_int16 ( A , B , TOLERANCE ) result ( answer ) ! TF = isequal(A) returns the logical scalar 1 (true) when the elements of A are identical to elementsof B or  0 (false) otherwise. integer ( kind = int16 ), intent ( in ) :: A (:) integer ( kind = int16 ), intent ( in ) :: B (:) integer ( kind = int16 ), intent ( in ), optional :: TOLERANCE integer ( kind = int16 ) :: DELTA integer :: answer integer :: i answer = 1 if ( present ( tolerance )) then delta = tolerance else delta = 0 endif if ( size ( A ). eq . size ( B )) then ! A merge() might not short-circuit or make copies? if ( delta . eq . 0 ) then do i = 1 , size ( A ) if ( A ( i ) /= B ( i )) then answer = 0 exit endif enddo else do i = 1 , size ( A ) if ( abs ( A ( i ) - B ( i )). gt . delta ) then answer = 0 exit endif enddo endif else answer = 0 endif end function isequal_int16 function unique_int32 ( A , setOrder ) result ( answer ) ! C = unique(A) returns the same data as in A, but with no repetitions. C is in sorted order. integer ( kind = int32 ), intent ( in ) :: A (:) character ( len =* ), intent ( in ), optional :: setOrder integer ( kind = int32 ), allocatable :: answer (:) integer , allocatable :: indices (:) character ( len = :), allocatable :: setOrder_ integer :: nuni if ( present ( setOrder )) then setOrder_ = setOrder else setOrder_ = 'sorted' endif answer = A select case ( lower ( setOrder_ )) case ( 'stable' ) call unique_ ( answer , nuni ) answer = answer (: nuni ) case ( 'sorted' ) if ( allocated ( indices )) deallocate ( indices ) allocate ( indices ( size ( A ))) call rank_unique_ ( A , indices , nuni ) answer = A ( indices (: nuni )) case default stop '*unique* unknown setOrder ' // setOrder_ // 'allowed are \"stable\" and \"sorted\"' end select end function unique_int32 function union_int32 ( A , B , setOrder ) result ( answer ) ! C = union(A,B) returns the combined data from A and B with no repetitions. C is in sorted order. integer ( kind = int32 ), intent ( in ) :: A (:) integer ( kind = int32 ), intent ( in ) :: B (:) character ( len =* ), intent ( in ), optional :: setOrder integer ( kind = int32 ), allocatable :: answer (:) answer = unique ([ A , B ], setOrder ) end function union_int32 function intersect_int32 ( A , B , setOrder ) result ( answer ) ! C = intersect(A,B) returns the data common to both A and B, with no repetitions. C is in sorted order by default integer ( kind = int32 ), intent ( in ) :: A (:) integer ( kind = int32 ), intent ( in ) :: B (:) character ( len =* ), intent ( in ), optional :: setOrder integer ( kind = int32 ), allocatable :: answer (:) integer , allocatable :: iwrk (:) answer = [ unique ( A , setOrder ), unique ( B , setOrder )] if ( allocated ( iwrk )) deallocate ( iwrk ) allocate ( iwrk ( size ( answer ))) call occurrences_ ( answer , iwrk ) answer = unique ( pack ( answer , iwrk > 1 ), setOrder ) end function intersect_int32 function setdiff_int32 ( A , B , setOrder ) result ( answer ) ! C = setdiff(A,B) returns the data in A that is not in B, with no repetitions. C is in sorted order by default. integer ( kind = int32 ), intent ( in ) :: a (:) integer ( kind = int32 ), intent ( in ) :: b (:) character ( len =* ), intent ( in ), optional :: setOrder integer ( kind = int32 ), allocatable :: answer (:) integer , allocatable :: iwrk (:) answer = unique ( b , setOrder = 'stable' ) answer = [ unique ( a , setOrder = 'stable' ), answer , answer ] ! potentially a lot of memory if ( allocated ( iwrk )) deallocate ( iwrk ) allocate ( iwrk ( size ( answer ))) call occurrences_ ( answer , iwrk ) answer = unique ( pack ( answer , iwrk == 1 ), setOrder ) end function setdiff_int32 function ismember_int32 ( A , B ) result ( answer ) ! C = ismember(A,B) returns an array containing 1 (true) where the data in A is found in B. Elsewhere, the array contains 0 integer ( kind = int32 ), intent ( in ) :: a (:) integer ( kind = int32 ), intent ( in ) :: b (:) integer ( kind = int32 ), allocatable :: ab (:) integer , allocatable :: answer (:) integer , allocatable :: iwrk1 (:) integer , allocatable :: iwrk2 (:) integer :: inums inums = size ( a ) ab = [ a , unique ( b ) ] ! potentially a lot of memory if ( allocated ( iwrk2 )) deallocate ( iwrk2 ) allocate ( iwrk2 ( size ( a ))) if ( allocated ( iwrk1 )) deallocate ( iwrk1 ) allocate ( iwrk1 ( size ( ab ))) call occurrences_ ( ab , iwrk1 ) call occurrences_ ( a , iwrk2 ) answer = iwrk1 (: inums ) - iwrk2 answer = merge ( 0 , 1 , answer == 0 ) end function ismember_int32 function setxor_int32 ( A , B , setOrder ) result ( answer ) ! C = setxor(A,B,setOrder) returns the data of A and B that are not in their intersection !                          (the symmetric difference), with no repetitions. That is, setxor returns the !                          data that occurs in A or B, but not both. C is in sorted order. integer ( kind = int32 ), intent ( in ) :: a (:) integer ( kind = int32 ), intent ( in ) :: b (:) character ( len =* ), intent ( in ), optional :: setOrder integer ( kind = int32 ), allocatable :: answer (:) integer , allocatable :: iwrk1 (:) integer , allocatable :: iwrk2 (:) integer , allocatable :: iwrk3 (:) integer :: inums inums = size ( a ) answer = [ a , b ] ! potentially a lot of memory if ( allocated ( iwrk1 )) deallocate ( iwrk1 ) allocate ( iwrk1 ( size ( answer ))) call occurrences_ ( answer , iwrk1 ) if ( allocated ( iwrk2 )) deallocate ( iwrk2 ) allocate ( iwrk2 ( size ( a ))) call occurrences_ ( a , iwrk2 ) if ( allocated ( iwrk3 )) deallocate ( iwrk3 ) allocate ( iwrk3 ( size ( b ))) call occurrences_ ( b , iwrk3 ) iwrk1 = iwrk1 - [ iwrk2 , iwrk3 ] answer = pack ( answer , iwrk1 == 0 ) answer = unique ( answer , setOrder ) end function setxor_int32 function issorted_int32 ( A ) result ( answer ) ! TF = issorted(A) returns the logical scalar 1 (true) when the elements of A are listed in ascending order and 0 (false) otherwise. integer ( kind = int32 ), intent ( in ) :: A (:) integer :: answer integer :: i answer = 1 do i = 1 , size ( a ) - 1 if ( A ( i ) > A ( i + 1 )) then answer = 0 exit endif enddo end function issorted_int32 function isequal_int32 ( A , B , TOLERANCE ) result ( answer ) ! TF = isequal(A) returns the logical scalar 1 (true) when the elements of A are identical to elementsof B or  0 (false) otherwise. integer ( kind = int32 ), intent ( in ) :: A (:) integer ( kind = int32 ), intent ( in ) :: B (:) integer ( kind = int32 ), intent ( in ), optional :: TOLERANCE integer ( kind = int32 ) :: DELTA integer :: answer integer :: i answer = 1 if ( present ( tolerance )) then delta = tolerance else delta = 0 endif if ( size ( A ). eq . size ( B )) then ! A merge() might not short-circuit or make copies? if ( delta . eq . 0 ) then do i = 1 , size ( A ) if ( A ( i ) /= B ( i )) then answer = 0 exit endif enddo else do i = 1 , size ( A ) if ( abs ( A ( i ) - B ( i )). gt . delta ) then answer = 0 exit endif enddo endif else answer = 0 endif end function isequal_int32 function unique_int64 ( A , setOrder ) result ( answer ) ! C = unique(A) returns the same data as in A, but with no repetitions. C is in sorted order. integer ( kind = int64 ), intent ( in ) :: A (:) character ( len =* ), intent ( in ), optional :: setOrder integer ( kind = int64 ), allocatable :: answer (:) integer , allocatable :: indices (:) character ( len = :), allocatable :: setOrder_ integer :: nuni if ( present ( setOrder )) then setOrder_ = setOrder else setOrder_ = 'sorted' endif answer = A select case ( lower ( setOrder_ )) case ( 'stable' ) call unique_ ( answer , nuni ) answer = answer (: nuni ) case ( 'sorted' ) if ( allocated ( indices )) deallocate ( indices ) allocate ( indices ( size ( A ))) call rank_unique_ ( A , indices , nuni ) answer = A ( indices (: nuni )) case default stop '*unique* unknown setOrder ' // setOrder_ // 'allowed are \"stable\" and \"sorted\"' end select end function unique_int64 function union_int64 ( A , B , setOrder ) result ( answer ) ! C = union(A,B) returns the combined data from A and B with no repetitions. C is in sorted order. integer ( kind = int64 ), intent ( in ) :: A (:) integer ( kind = int64 ), intent ( in ) :: B (:) character ( len =* ), intent ( in ), optional :: setOrder integer ( kind = int64 ), allocatable :: answer (:) answer = unique ([ A , B ], setOrder ) end function union_int64 function intersect_int64 ( A , B , setOrder ) result ( answer ) ! C = intersect(A,B) returns the data common to both A and B, with no repetitions. C is in sorted order by default integer ( kind = int64 ), intent ( in ) :: A (:) integer ( kind = int64 ), intent ( in ) :: B (:) character ( len =* ), intent ( in ), optional :: setOrder integer ( kind = int64 ), allocatable :: answer (:) integer , allocatable :: iwrk (:) answer = [ unique ( A , setOrder ), unique ( B , setOrder )] if ( allocated ( iwrk )) deallocate ( iwrk ) allocate ( iwrk ( size ( answer ))) call occurrences_ ( answer , iwrk ) answer = unique ( pack ( answer , iwrk > 1 ), setOrder ) end function intersect_int64 function setdiff_int64 ( A , B , setOrder ) result ( answer ) ! C = setdiff(A,B) returns the data in A that is not in B, with no repetitions. C is in sorted order by default. integer ( kind = int64 ), intent ( in ) :: a (:) integer ( kind = int64 ), intent ( in ) :: b (:) character ( len =* ), intent ( in ), optional :: setOrder integer ( kind = int64 ), allocatable :: answer (:) integer , allocatable :: iwrk (:) answer = unique ( b , setOrder = 'stable' ) answer = [ unique ( a , setOrder = 'stable' ), answer , answer ] ! potentially a lot of memory if ( allocated ( iwrk )) deallocate ( iwrk ) allocate ( iwrk ( size ( answer ))) call occurrences_ ( answer , iwrk ) answer = unique ( pack ( answer , iwrk == 1 ), setOrder ) end function setdiff_int64 function ismember_int64 ( A , B ) result ( answer ) ! C = ismember(A,B) returns an array containing 1 (true) where the data in A is found in B. Elsewhere, the array contains 0 integer ( kind = int64 ), intent ( in ) :: a (:) integer ( kind = int64 ), intent ( in ) :: b (:) integer ( kind = int64 ), allocatable :: ab (:) integer , allocatable :: answer (:) integer , allocatable :: iwrk1 (:) integer , allocatable :: iwrk2 (:) integer :: inums inums = size ( a ) ab = [ a , unique ( b ) ] ! potentially a lot of memory if ( allocated ( iwrk2 )) deallocate ( iwrk2 ) allocate ( iwrk2 ( size ( a ))) if ( allocated ( iwrk1 )) deallocate ( iwrk1 ) allocate ( iwrk1 ( size ( ab ))) call occurrences_ ( ab , iwrk1 ) call occurrences_ ( a , iwrk2 ) answer = iwrk1 (: inums ) - iwrk2 answer = merge ( 0 , 1 , answer == 0 ) end function ismember_int64 function setxor_int64 ( A , B , setOrder ) result ( answer ) ! C = setxor(A,B,setOrder) returns the data of A and B that are not in their intersection !                          (the symmetric difference), with no repetitions. That is, setxor returns the !                          data that occurs in A or B, but not both. C is in sorted order. integer ( kind = int64 ), intent ( in ) :: a (:) integer ( kind = int64 ), intent ( in ) :: b (:) character ( len =* ), intent ( in ), optional :: setOrder integer ( kind = int64 ), allocatable :: answer (:) integer , allocatable :: iwrk1 (:) integer , allocatable :: iwrk2 (:) integer , allocatable :: iwrk3 (:) integer :: inums inums = size ( a ) answer = [ a , b ] ! potentially a lot of memory if ( allocated ( iwrk1 )) deallocate ( iwrk1 ) allocate ( iwrk1 ( size ( answer ))) call occurrences_ ( answer , iwrk1 ) if ( allocated ( iwrk2 )) deallocate ( iwrk2 ) allocate ( iwrk2 ( size ( a ))) call occurrences_ ( a , iwrk2 ) if ( allocated ( iwrk3 )) deallocate ( iwrk3 ) allocate ( iwrk3 ( size ( b ))) call occurrences_ ( b , iwrk3 ) iwrk1 = iwrk1 - [ iwrk2 , iwrk3 ] answer = pack ( answer , iwrk1 == 0 ) answer = unique ( answer , setOrder ) end function setxor_int64 function issorted_int64 ( A ) result ( answer ) ! TF = issorted(A) returns the logical scalar 1 (true) when the elements of A are listed in ascending order and 0 (false) otherwise. integer ( kind = int64 ), intent ( in ) :: A (:) integer :: answer integer :: i answer = 1 do i = 1 , size ( a ) - 1 if ( A ( i ) > A ( i + 1 )) then answer = 0 exit endif enddo end function issorted_int64 function isequal_int64 ( A , B , TOLERANCE ) result ( answer ) ! TF = isequal(A) returns the logical scalar 1 (true) when the elements of A are identical to elementsof B or  0 (false) otherwise. integer ( kind = int64 ), intent ( in ) :: A (:) integer ( kind = int64 ), intent ( in ) :: B (:) integer ( kind = int64 ), intent ( in ), optional :: TOLERANCE integer ( kind = int64 ) :: DELTA integer :: answer integer :: i answer = 1 if ( present ( tolerance )) then delta = tolerance else delta = 0 endif if ( size ( A ). eq . size ( B )) then ! A merge() might not short-circuit or make copies? if ( delta . eq . 0 ) then do i = 1 , size ( A ) if ( A ( i ) /= B ( i )) then answer = 0 exit endif enddo else do i = 1 , size ( A ) if ( abs ( A ( i ) - B ( i )). gt . delta ) then answer = 0 exit endif enddo endif else answer = 0 endif end function isequal_int64 function unique_real32 ( A , setOrder ) result ( answer ) ! C = unique(A) returns the same data as in A, but with no repetitions. C is in sorted order. real ( kind = real32 ), intent ( in ) :: A (:) character ( len =* ), intent ( in ), optional :: setOrder real ( kind = real32 ), allocatable :: answer (:) integer , allocatable :: indices (:) character ( len = :), allocatable :: setOrder_ integer :: nuni if ( present ( setOrder )) then setOrder_ = setOrder else setOrder_ = 'sorted' endif answer = A select case ( lower ( setOrder_ )) case ( 'stable' ) call unique_ ( answer , nuni ) answer = answer (: nuni ) case ( 'sorted' ) if ( allocated ( indices )) deallocate ( indices ) allocate ( indices ( size ( A ))) call rank_unique_ ( A , indices , nuni ) answer = A ( indices (: nuni )) case default stop '*unique* unknown setOrder ' // setOrder_ // 'allowed are \"stable\" and \"sorted\"' end select end function unique_real32 function union_real32 ( A , B , setOrder ) result ( answer ) ! C = union(A,B) returns the combined data from A and B with no repetitions. C is in sorted order. real ( kind = real32 ), intent ( in ) :: A (:) real ( kind = real32 ), intent ( in ) :: B (:) character ( len =* ), intent ( in ), optional :: setOrder real ( kind = real32 ), allocatable :: answer (:) answer = unique ([ A , B ], setOrder ) end function union_real32 function intersect_real32 ( A , B , setOrder ) result ( answer ) ! C = intersect(A,B) returns the data common to both A and B, with no repetitions. C is in sorted order by default real ( kind = real32 ), intent ( in ) :: A (:) real ( kind = real32 ), intent ( in ) :: B (:) character ( len =* ), intent ( in ), optional :: setOrder real ( kind = real32 ), allocatable :: answer (:) integer , allocatable :: iwrk (:) answer = [ unique ( A , setOrder ), unique ( B , setOrder )] if ( allocated ( iwrk )) deallocate ( iwrk ) allocate ( iwrk ( size ( answer ))) call occurrences_ ( answer , iwrk ) answer = unique ( pack ( answer , iwrk > 1 ), setOrder ) end function intersect_real32 function setdiff_real32 ( A , B , setOrder ) result ( answer ) ! C = setdiff(A,B) returns the data in A that is not in B, with no repetitions. C is in sorted order by default. real ( kind = real32 ), intent ( in ) :: a (:) real ( kind = real32 ), intent ( in ) :: b (:) character ( len =* ), intent ( in ), optional :: setOrder real ( kind = real32 ), allocatable :: answer (:) integer , allocatable :: iwrk (:) answer = unique ( b , setOrder = 'stable' ) answer = [ unique ( a , setOrder = 'stable' ), answer , answer ] ! potentially a lot of memory if ( allocated ( iwrk )) deallocate ( iwrk ) allocate ( iwrk ( size ( answer ))) call occurrences_ ( answer , iwrk ) answer = unique ( pack ( answer , iwrk == 1 ), setOrder ) end function setdiff_real32 function ismember_real32 ( A , B ) result ( answer ) ! C = ismember(A,B) returns an array containing 1 (true) where the data in A is found in B. Elsewhere, the array contains 0 real ( kind = real32 ), intent ( in ) :: a (:) real ( kind = real32 ), intent ( in ) :: b (:) real ( kind = real32 ), allocatable :: ab (:) integer , allocatable :: answer (:) integer , allocatable :: iwrk1 (:) integer , allocatable :: iwrk2 (:) integer :: inums inums = size ( a ) ab = [ a , unique ( b ) ] ! potentially a lot of memory if ( allocated ( iwrk2 )) deallocate ( iwrk2 ) allocate ( iwrk2 ( size ( a ))) if ( allocated ( iwrk1 )) deallocate ( iwrk1 ) allocate ( iwrk1 ( size ( ab ))) call occurrences_ ( ab , iwrk1 ) call occurrences_ ( a , iwrk2 ) answer = iwrk1 (: inums ) - iwrk2 answer = merge ( 0 , 1 , answer == 0 ) end function ismember_real32 function setxor_real32 ( A , B , setOrder ) result ( answer ) ! C = setxor(A,B,setOrder) returns the data of A and B that are not in their intersection !                          (the symmetric difference), with no repetitions. That is, setxor returns the !                          data that occurs in A or B, but not both. C is in sorted order. real ( kind = real32 ), intent ( in ) :: a (:) real ( kind = real32 ), intent ( in ) :: b (:) character ( len =* ), intent ( in ), optional :: setOrder real ( kind = real32 ), allocatable :: answer (:) integer , allocatable :: iwrk1 (:) integer , allocatable :: iwrk2 (:) integer , allocatable :: iwrk3 (:) integer :: inums inums = size ( a ) answer = [ a , b ] ! potentially a lot of memory if ( allocated ( iwrk1 )) deallocate ( iwrk1 ) allocate ( iwrk1 ( size ( answer ))) call occurrences_ ( answer , iwrk1 ) if ( allocated ( iwrk2 )) deallocate ( iwrk2 ) allocate ( iwrk2 ( size ( a ))) call occurrences_ ( a , iwrk2 ) if ( allocated ( iwrk3 )) deallocate ( iwrk3 ) allocate ( iwrk3 ( size ( b ))) call occurrences_ ( b , iwrk3 ) iwrk1 = iwrk1 - [ iwrk2 , iwrk3 ] answer = pack ( answer , iwrk1 == 0 ) answer = unique ( answer , setOrder ) end function setxor_real32 function issorted_real32 ( A ) result ( answer ) ! TF = issorted(A) returns the logical scalar 1 (true) when the elements of A are listed in ascending order and 0 (false) otherwise. real ( kind = real32 ), intent ( in ) :: A (:) integer :: answer integer :: i answer = 1 do i = 1 , size ( a ) - 1 if ( A ( i ) > A ( i + 1 )) then answer = 0 exit endif enddo end function issorted_real32 function isequal_real32 ( A , B , TOLERANCE ) result ( answer ) ! TF = isequal(A) returns the logical scalar 1 (true) when the elements of A are identical to elementsof B or  0 (false) otherwise. real ( kind = real32 ), intent ( in ) :: A (:) real ( kind = real32 ), intent ( in ) :: B (:) real ( kind = real32 ), intent ( in ), optional :: TOLERANCE real ( kind = real32 ) :: DELTA integer :: answer integer :: i answer = 1 if ( present ( tolerance )) then delta = tolerance else delta = 0 endif if ( size ( A ). eq . size ( B )) then ! A merge() might not short-circuit or make copies? if ( delta . eq . 0 ) then do i = 1 , size ( A ) if ( A ( i ) /= B ( i )) then answer = 0 exit endif enddo else do i = 1 , size ( A ) if ( abs ( A ( i ) - B ( i )). gt . delta ) then answer = 0 exit endif enddo endif else answer = 0 endif end function isequal_real32 function unique_real64 ( A , setOrder ) result ( answer ) ! C = unique(A) returns the same data as in A, but with no repetitions. C is in sorted order. real ( kind = real64 ), intent ( in ) :: A (:) character ( len =* ), intent ( in ), optional :: setOrder real ( kind = real64 ), allocatable :: answer (:) integer , allocatable :: indices (:) character ( len = :), allocatable :: setOrder_ integer :: nuni if ( present ( setOrder )) then setOrder_ = setOrder else setOrder_ = 'sorted' endif answer = A select case ( lower ( setOrder_ )) case ( 'stable' ) call unique_ ( answer , nuni ) answer = answer (: nuni ) case ( 'sorted' ) if ( allocated ( indices )) deallocate ( indices ) allocate ( indices ( size ( A ))) call rank_unique_ ( A , indices , nuni ) answer = A ( indices (: nuni )) case default stop '*unique* unknown setOrder ' // setOrder_ // 'allowed are \"stable\" and \"sorted\"' end select end function unique_real64 function union_real64 ( A , B , setOrder ) result ( answer ) ! C = union(A,B) returns the combined data from A and B with no repetitions. C is in sorted order. real ( kind = real64 ), intent ( in ) :: A (:) real ( kind = real64 ), intent ( in ) :: B (:) character ( len =* ), intent ( in ), optional :: setOrder real ( kind = real64 ), allocatable :: answer (:) answer = unique ([ A , B ], setOrder ) end function union_real64 function intersect_real64 ( A , B , setOrder ) result ( answer ) ! C = intersect(A,B) returns the data common to both A and B, with no repetitions. C is in sorted order by default real ( kind = real64 ), intent ( in ) :: A (:) real ( kind = real64 ), intent ( in ) :: B (:) character ( len =* ), intent ( in ), optional :: setOrder real ( kind = real64 ), allocatable :: answer (:) integer , allocatable :: iwrk (:) answer = [ unique ( A , setOrder ), unique ( B , setOrder )] if ( allocated ( iwrk )) deallocate ( iwrk ) allocate ( iwrk ( size ( answer ))) call occurrences_ ( answer , iwrk ) answer = unique ( pack ( answer , iwrk > 1 ), setOrder ) end function intersect_real64 function setdiff_real64 ( A , B , setOrder ) result ( answer ) ! C = setdiff(A,B) returns the data in A that is not in B, with no repetitions. C is in sorted order by default. real ( kind = real64 ), intent ( in ) :: a (:) real ( kind = real64 ), intent ( in ) :: b (:) character ( len =* ), intent ( in ), optional :: setOrder real ( kind = real64 ), allocatable :: answer (:) integer , allocatable :: iwrk (:) answer = unique ( b , setOrder = 'stable' ) answer = [ unique ( a , setOrder = 'stable' ), answer , answer ] ! potentially a lot of memory if ( allocated ( iwrk )) deallocate ( iwrk ) allocate ( iwrk ( size ( answer ))) call occurrences_ ( answer , iwrk ) answer = unique ( pack ( answer , iwrk == 1 ), setOrder ) end function setdiff_real64 function ismember_real64 ( A , B ) result ( answer ) ! C = ismember(A,B) returns an array containing 1 (true) where the data in A is found in B. Elsewhere, the array contains 0 real ( kind = real64 ), intent ( in ) :: a (:) real ( kind = real64 ), intent ( in ) :: b (:) real ( kind = real64 ), allocatable :: ab (:) integer , allocatable :: answer (:) integer , allocatable :: iwrk1 (:) integer , allocatable :: iwrk2 (:) integer :: inums inums = size ( a ) ab = [ a , unique ( b ) ] ! potentially a lot of memory if ( allocated ( iwrk2 )) deallocate ( iwrk2 ) allocate ( iwrk2 ( size ( a ))) if ( allocated ( iwrk1 )) deallocate ( iwrk1 ) allocate ( iwrk1 ( size ( ab ))) call occurrences_ ( ab , iwrk1 ) call occurrences_ ( a , iwrk2 ) answer = iwrk1 (: inums ) - iwrk2 answer = merge ( 0 , 1 , answer == 0 ) end function ismember_real64 function setxor_real64 ( A , B , setOrder ) result ( answer ) ! C = setxor(A,B,setOrder) returns the data of A and B that are not in their intersection !                          (the symmetric difference), with no repetitions. That is, setxor returns the !                          data that occurs in A or B, but not both. C is in sorted order. real ( kind = real64 ), intent ( in ) :: a (:) real ( kind = real64 ), intent ( in ) :: b (:) character ( len =* ), intent ( in ), optional :: setOrder real ( kind = real64 ), allocatable :: answer (:) integer , allocatable :: iwrk1 (:) integer , allocatable :: iwrk2 (:) integer , allocatable :: iwrk3 (:) integer :: inums inums = size ( a ) answer = [ a , b ] ! potentially a lot of memory if ( allocated ( iwrk1 )) deallocate ( iwrk1 ) allocate ( iwrk1 ( size ( answer ))) call occurrences_ ( answer , iwrk1 ) if ( allocated ( iwrk2 )) deallocate ( iwrk2 ) allocate ( iwrk2 ( size ( a ))) call occurrences_ ( a , iwrk2 ) if ( allocated ( iwrk3 )) deallocate ( iwrk3 ) allocate ( iwrk3 ( size ( b ))) call occurrences_ ( b , iwrk3 ) iwrk1 = iwrk1 - [ iwrk2 , iwrk3 ] answer = pack ( answer , iwrk1 == 0 ) answer = unique ( answer , setOrder ) end function setxor_real64 function issorted_real64 ( A ) result ( answer ) ! TF = issorted(A) returns the logical scalar 1 (true) when the elements of A are listed in ascending order and 0 (false) otherwise. real ( kind = real64 ), intent ( in ) :: A (:) integer :: answer integer :: i answer = 1 do i = 1 , size ( a ) - 1 if ( A ( i ) > A ( i + 1 )) then answer = 0 exit endif enddo end function issorted_real64 function isequal_real64 ( A , B , TOLERANCE ) result ( answer ) ! TF = isequal(A) returns the logical scalar 1 (true) when the elements of A are identical to elementsof B or  0 (false) otherwise. real ( kind = real64 ), intent ( in ) :: A (:) real ( kind = real64 ), intent ( in ) :: B (:) real ( kind = real64 ), intent ( in ), optional :: TOLERANCE real ( kind = real64 ) :: DELTA integer :: answer integer :: i answer = 1 if ( present ( tolerance )) then delta = tolerance else delta = 0 endif if ( size ( A ). eq . size ( B )) then ! A merge() might not short-circuit or make copies? if ( delta . eq . 0 ) then do i = 1 , size ( A ) if ( A ( i ) /= B ( i )) then answer = 0 exit endif enddo else do i = 1 , size ( A ) if ( abs ( A ( i ) - B ( i )). gt . delta ) then answer = 0 exit endif enddo endif else answer = 0 endif end function isequal_real64 !> !!##NAME !!    bool(3f) - [M_sets::LOGICAL] returns One if expression is TRUE, !!    else returns Zero. !!    (LICENSE:PD) !!##SYNOPSIS !! !! !!    pure elemental integer function bool(expr) !! !!     logical,intent(in) :: expr !!       or !!     character(len=:)intent(in) :: expr !!       or !!     integer|real|complex(in) :: expr !! !!##DESCRIPTION !! !!    bool(3f) returns an integer 1 given a true logical expression. !! !!##OPTIONS !! expr  A logical expression. If any other intrinsic type a blank string is !!       TRUE as well as 0. 0.0, and (0.0,0.0). Non-zero numeric values !!       and non-blank or non-null strings are FALSE. !! !!##RETURNS !! !!   The result is a default INTEGER value of 1 if the expression is TRUE, !!   and a 0 otherwise. !! !!##EXAMPLES !! !!  Sample usage: !! !!    program demo_bool !!    use M_sets, only: bool !!    implicit none !!       write (*, *) 'is 10 < 20 ?', bool(10 < 20) !!       write (*, *) 'elemental', bool([2 > 1, 3 == 4, 10 < 5, 100 > 50]) !!       if (sum(bool([2 > 1, 3 == 4, 10 < 5, 100 > 50])) >= 2) then !!          write (*, *) 'two or more are true' !!       endif !!    end program demo_bool !! !!  Results: !! !!     > is 10 < 20 ? 1 !!     > elemental 1 0 0 1 !!     > two or more are true !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    CC0-1.0 pure elemental integer function bool_expr ( expr ) ! ident_2=\"@(#) M_sets bool(3f) logical to integer TRUE results in 1 FALSE results in 0\" logical , intent ( in ) :: expr bool_expr = merge ( 1 , 0 , expr ) ! One and Zero end function bool_expr pure elemental integer function bool_int8 ( int ); integer ( kind = int8 ), intent ( in ) :: int ; bool_int8 = merge ( 1 , 0 , int == 0 ); end pure elemental integer function bool_int16 ( int ); integer ( kind = int16 ), intent ( in ) :: int ; bool_int16 = merge ( 1 , 0 , int == 0 ); end pure elemental integer function bool_int32 ( int ); integer ( kind = int32 ), intent ( in ) :: int ; bool_int32 = merge ( 1 , 0 , int == 0 ); end pure elemental integer function bool_int64 ( int ); integer ( kind = int64 ), intent ( in ) :: int ; bool_int64 = merge ( 1 , 0 , int == 0 ); end pure elemental integer function bool_float32 ( float ); real ( kind = real32 ), intent ( in ) :: float ; bool_float32 = merge ( 1 , 0 , float == 0.0 ); end pure elemental integer function bool_float64 ( float ); real ( kind = real64 ), intent ( in ) :: float ; bool_float64 = merge ( 1 , 0 , float == 0.0 ); end pure elemental integer function bool_complex32 ( val ) complex ( kind = real32 ), intent ( in ) :: val bool_complex32 = merge ( 1 , 0 , abs ( val ) == 0.0_real32 ) end function bool_complex32 pure elemental integer function bool_complex64 ( val ) complex ( kind = real64 ), intent ( in ) :: val bool_complex64 = merge ( 1 , 0 , abs ( val ) == 0.0_real64 ) end function bool_complex64 pure elemental integer function bool_char ( string ) character ( len =* ), intent ( in ) :: string bool_char = merge ( 1 , 0 , string == '' ) end function bool_char end module M_sets","tags":"","url":"sourcefile/m_sets.f90.html"},{"title":"performance.f90 – M_sets","text":"Source Code program main ! measure general performance by operating on 1 000 000, random values use M_sets , only : unique , intersect , union , setdiff , ismember , setxor , bool implicit none real :: valsr ( 1000000 ) integer , allocatable :: A (:) integer , allocatable :: B (:) integer , allocatable :: C (:) integer :: i character ( len =* ), parameter :: g = '(*(g0,1x))' call random_seed () do i = 1 , 10 call random_number ( valsr ) A = valsr * 2 0.0 - 1 0.0 B = [( i , i =- 10 , 10 )] write ( * , g ) A C = unique ( A ) write ( * , g ) 'UNIQUE:    NUMBER OF VALUES RETURNED:' , size ( C ), C C = intersect ( A , B ) write ( * , g ) 'INTERSECT: NUMBER OF VALUES RETURNED:' , size ( C ), C C = union ( A , B ) write ( * , g ) 'UNION:     NUMBER OF VALUES RETURNED:' , size ( C ), C C = setdiff ( A , B ) write ( * , g ) 'SETDIFF:   NUMBER OF VALUES RETURNED:' , size ( C ), C C = ismember ( A , B ) write ( * , g ) 'ISMEMBER:  NUMBER OF VALUES RETURNED:' , size ( C ) C = setxor ( A , B ) write ( * , g ) 'SETXOR:    NUMBER OF VALUES RETURNED:' , size ( C ), C end do end program main","tags":"","url":"sourcefile/performance.f90.html"},{"title":"demo_M_sets.f90 – M_sets","text":"Source Code program demo_M_sets use M_sets , only : & & unique , intersect , union , setdiff , setxor , bool , & & ismember , issorted , isequal character ( len =* ), parameter :: all = '(*(g0,1x))' character ( len =* ), parameter :: nl = new_line ( 'A' ) integer , allocatable :: A (:) integer , allocatable :: B (:) integer , allocatable :: C (:) A = [ 10 , - 10 , 0 , 1 , 2 , 3 , 3 , 2 , 1 , - 10 ] ! print all , nl , & 'UNIQUE' , 'Find the unique elements of vector A.' , nl , & 'A=' , A , nl , & 'sorted=' , unique ( A ) , nl , & 'stable=' , unique ( A , setOrder = 'stable' ) A = [ 5 , 7 , 1 ] B = [ 3 , 1 , 1 ] ! print all , nl , & 'UNION' , 'Find the union of vectors A and B.' , nl , & 'A=' , A , nl , & 'B=' , B , nl , & 'sorted=' , union ( A , B , 'sorted' ) , nl , & 'stable=' , union ( A , B , 'stable' ) A = [ 7 , 1 , 7 , 7 , 4 ] B = [ 7 , 0 , 4 , 4 , 0 ] ! print all , nl , & 'INTERSECT' , 'Find the values common to both A and B.' , nl , & 'A=' , A , nl , & 'B=' , B , nl , & 'sorted=' , intersect ( A , B ) , nl , & 'stable=' , intersect ( A , B , setOrder = 'stable' ) A = [ 3 , 6 , 2 , 1 , 5 , 1 , 1 ] B = [ 2 , 4 , 6 ] ! print all , nl , & 'SETDIFF' , 'Find the values in A that are not in B.' , nl , & 'A=' , A , nl , & 'B=' , B , nl , & 'sorted=' , setdiff ( A , B , 'sorted' ) , nl , & 'stable=' , setdiff ( A , B , 'stable' ) A = [ 5 , 3 , 4 , 2 ] B = [ 2 , 4 , 4 , 4 , 6 , 8 ] ! print all , nl , & 'ISMEMBER' , 'Determine which elements of A are also in B.' , nl , & 'A=' , A , nl , & 'B=' , B , nl , & 'in A and B=' , ismember ( A , B ) A = [ 5 , 1 , 3 , 3 , 3 ] B = [ 4 , 1 , 2 ] ! print all , nl , & 'SETXOR' , & 'Find values of A and B not in their intersection.' , nl , & 'A=' , A , nl , & 'B=' , B , nl , & 'sorted=' , setxor ( A , B ) , nl , & 'stable=' , setxor ( A , B , 'stable' ) A = [ 1 , 2 , 3 , 4 , 5 ] B = [ 5 , 4 , 3 , 2 , 1 ] ! print all , nl , & 'ISSSORTED' , & 'confirm whether array is sorted in ascending order or not' , nl , & 'A=' , A , nl , & 'B=' , B , nl , & 'is A sorted?' , issorted ( A ) , nl , & 'is B sorted?' , issorted ( B ) A = [ 1 , 2 , 3 , 4 , 5 ] B = [ 1 , 2 , 3 , 4 , 5 ] ! print all , nl , & 'ISEQUAL' , & 'confirm whether sets have same elements in same order    ' , nl , & 'A=' , A , nl , & 'B=' , B , nl , & 'is A equal to B?' , isequal ( A , B ) , nl , & 'is B equal to -B?' , isequal ( A , - B ) A = [ 1 , 2 , 3 , 4 , 5 ] B = [ 5 , 2 , 3 , 4 , 1 ] ! print all , nl , & 'BOOL' , & 'if logical expression is true, 0 if false.' , nl , & 'A=' , A , nl , & 'B=' , B , nl , & 'is A(i) = B(i) ?' , bool ( A == B ) , nl , & 'how many elements are the same?' , sum ( bool ( A == B )) end program demo_M_sets","tags":"","url":"sourcefile/demo_m_sets.f90.html"},{"title":"test_suite_M_sets.f90 – M_sets","text":"Source Code program runtest use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 use M_framework use M_sets , only : unique , intersect , union , setdiff , ismember , setxor , issorted , isequal , bool ! implicit none integer , allocatable :: a (:) integer , allocatable :: b (:) integer , allocatable :: c (:) integer , allocatable :: expected (:) real , allocatable :: fltA (:) real , allocatable :: fltB (:) real , allocatable :: fltC (:) real , allocatable :: fltexpected (:) character ( len = :), allocatable :: strA (:) character ( len = :), allocatable :: strB (:) character ( len = :), allocatable :: strC (:) character ( len = :), allocatable :: strexpected (:) unit_test_level = 0 call test_unique () call test_intersect () call test_union () call test_setdiff () call test_ismember () call test_setxor () call test_issorted () call test_isequal () call test_bool () call unit_test_stop () contains !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_unique call unit_test_start ( 'unique' , 'find the unique elements of vactor A' ) ! start tests A = [ 10 , - 10 , 0 , 1 , 2 , 3 , 3 , 2 , 1 , - 10 ] strA = [ 'ab' , 'AB' , 'zz' , 'mq' , 'qm' , 'mq' , 'Za' , 'zz' , 'bb' , 'qm' ] C = unique ( A ) expected = [ - 10 , 0 , 1 , 2 , 3 , 10 ] call unit_test ( 'unique' , size ( C ). eq . size ( expected ), 'sorted size' ) if ( size ( C ). eq . size ( expected )) then call unit_test ( 'unique' , all ( C . eq . expected ), 'sorted, expected' , str ( expected ), 'got' , str ( C )) endif C = unique ( A , setOrder = 'stable' ) expected = [ 10 , - 10 , 0 , 1 , 2 , 3 ] call unit_test ( 'unique' , size ( C ). eq . size ( expected ), 'stable size' ) if ( size ( C ). eq . size ( expected )) then call unit_test ( 'unique' , all ( C . eq . expected ), 'stable, expected' , str ( expected ), 'got' , str ( C )) endif strC = unique ( strA , setorder = 'stable' ) strexpected = [ 'ab' , 'AB' , 'zz' , 'mq' , 'qm' , 'Za' , 'bb' ] call unit_test ( 'unique' , size ( strC ). eq . size ( strexpected ), 'sorted size' ) if ( size ( strC ). eq . size ( strexpected )) then call unit_test ( 'unique' , all ( strC . eq . strexpected ), 'stable, expected' , str ( strexpected ), 'got' , str ( strC )) endif strC = unique ( strA , setorder = 'sorted' ) strexpected = [ \"AB\" , \"Za\" , \"ab\" , \"bb\" , \"mq\" , \"qm\" , \"zz\" ] call unit_test ( 'unique' , size ( strC ). eq . size ( strexpected ), 'sorted size' ) if ( size ( strC ). eq . size ( strexpected )) then call unit_test ( 'unique' , all ( strC . eq . strexpected ), 'sorted, expected' , str ( strexpected ), 'got' , str ( strC )) endif fltA = [ 1 0.1 , - 1 0.0 , 0.0 , 1.11 , 2.22 , 3.33 , 3.33 , 2.22 , 1.11 , - 1 0.0 ] fltC = unique ( fltA ) fltexpected = [ - 1 0.0 , 0.0 , 1.11 , 2.22 , 3.33 , 1 0.1 ] call unit_test ( 'unique' , size ( fltC ). eq . size ( fltexpected ), 'sorted size' ) if ( size ( fltC ). eq . size ( fltexpected )) then call unit_test ( 'unique' , all ( fltC . eq . fltexpected ), 'sorted, expected' , str ( fltexpected ), 'got' , str ( fltC )) endif fltC = unique ( fltA , setOrder = 'stable' ) fltexpected = [ 1 0.1 , - 1 0.0 , 0.0 , 1.11 , 2.22 , 3.33 ] call unit_test ( 'unique' , size ( fltC ). eq . size ( fltexpected ), 'stable size' ) if ( size ( fltC ). eq . size ( fltexpected )) then call unit_test ( 'unique' , all ( fltC . eq . fltexpected ), 'stable, expected' , str ( fltexpected ), 'got' , str ( fltC )) endif call unit_test_done ( 'unique' , msg = 'test completed' ) end subroutine test_unique !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_union call unit_test_start ( 'union' , 'find the unique elements of vactors A and B' ) ! start tests A = [ 5 , 7 , 1 ] B = [ 3 , 1 , 1 ] C = union ( A , B ) expected = [ 1 , 3 , 5 , 7 ] call unit_test ( 'union' , size ( C ). eq . size ( expected ), 'sorted size' ) if ( size ( C ). eq . size ( expected )) then call unit_test ( 'union' , all ( C . eq . expected ), 'default, expected' , str ( expected ), 'got' , str ( C )) endif A = [ 5 , 5 , 3 ] B = [ 1 , 2 , 5 ] C = union ( A , B , 'sorted' ) expected = [ 1 , 2 , 3 , 5 ] call unit_test ( 'union' , size ( C ). eq . size ( expected ), 'sorted size' ) if ( size ( C ). eq . size ( expected )) then call unit_test ( 'union' , all ( C . eq . expected ), 'sorted, expected' , str ( expected ), 'got' , str ( C )) endif C = union ( A , B , 'stable' ) expected = [ 5 , 3 , 1 , 2 ] call unit_test ( 'union' , size ( C ). eq . size ( expected ), 'stable size' ) if ( size ( C ). eq . size ( expected )) then call unit_test ( 'union' , all ( C . eq . expected ), 'stable, expected' , str ( expected ), 'got' , str ( C )) endif strA = [ \"5\" , \"7\" , \"1\" ] strB = [ \"3\" , \"1\" , \"1\" ] strC = union ( strA , strB ) strexpected = [ \"1\" , \"3\" , \"5\" , \"7\" ] call unit_test ( 'union' , size ( strC ). eq . size ( strexpected ), 'default size' , 'expected' , size ( strexpected ), 'got' , size ( strC )) if ( size ( strC ). eq . size ( strexpected )) then call unit_test ( 'union' , all ( strC . eq . strexpected ), 'default, expected' , str ( strexpected ), 'got' , str ( strC )) endif strA = [ \"5\" , \"5\" , \"3\" ] strB = [ \"1\" , \"2\" , \"5\" ] strC = union ( strA , strB , 'sorted' ) strexpected = [ \"1\" , \"2\" , \"3\" , \"5\" ] call unit_test ( 'union' , size ( strC ). eq . size ( strexpected ), 'sorted size' , 'expected' , size ( strexpected ), 'got' , size ( strC )) if ( size ( strC ). eq . size ( strexpected )) then call unit_test ( 'union' , all ( strC . eq . strexpected ), 'sorted, expected' , str ( strexpected ), 'got' , str ( strC )) endif strC = union ( strA , strB , 'stable' ) strexpected = [ \"5\" , \"3\" , \"1\" , \"2\" ] call unit_test ( 'union' , size ( strC ). eq . size ( strexpected ), 'stable size' , 'expected' , size ( strexpected ), 'got' , size ( strC )) if ( size ( strC ). eq . size ( strexpected )) then call unit_test ( 'union' , all ( strC . eq . strexpected ), 'stable, expected' , str ( strexpected ), 'got' , str ( strC )) endif fltA = [ 5.5 , 7.0 , 1.2345 ] fltB = [ 3.333 , 1.2345 , 1.2345 ] fltC = union ( fltA , fltB ) fltexpected = [ 1.2345 , 3.333 , 5.5 , 7.0 ] call unit_test ( 'union' , size ( fltC ). eq . size ( fltexpected ), 'sorted size' ) if ( size ( fltC ). eq . size ( fltexpected )) then call unit_test ( 'union' , all ( fltC . eq . fltexpected ), 'default, expected' , str ( fltexpected ), 'got' , str ( fltC )) endif fltA = [ 5.5 , 5.5 , 3.333 ] fltB = [ 1.234 , 2.0 , 5.5 ] fltC = union ( fltA , fltB , 'sorted' ) fltexpected = [ 1.234 , 2.0 , 3.333 , 5.5 ] call unit_test ( 'union' , size ( fltC ). eq . size ( fltexpected ), 'sorted size' ) if ( size ( fltC ). eq . size ( fltexpected )) then call unit_test ( 'union' , all ( fltC . eq . fltexpected ), 'sorted, expected' , str ( fltexpected ), 'got' , str ( fltC )) endif fltC = union ( fltA , fltB , 'stable' ) fltexpected = [ 5.5 , 3.333 , 1.234 , 2.0 ] call unit_test ( 'union' , size ( fltC ). eq . size ( fltexpected ), 'stable size' ) if ( size ( fltC ). eq . size ( fltexpected )) then call unit_test ( 'union' , all ( fltC . eq . fltexpected ), 'stable, expected' , str ( fltexpected ), 'got' , str ( fltC )) endif call unit_test_done ( 'union' , msg = 'test completed' ) end subroutine test_union !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_intersect call unit_test_start ( 'intersect' , 'find the values common to both A and B' ) ! start tests A = [ 7 , 1 , 7 , 7 , 4 ] B = [ 7 , 0 , 4 , 4 , 0 ] C = intersect ( A , B ) expected = [ 4 , 7 ] call unit_test ( 'intersect' , size ( C ). eq . size ( expected ), 'sorted size' , 'expected' , size ( expected ), 'got' , size ( c )) if ( size ( C ). eq . size ( expected )) then call unit_test ( 'intersect' , all ( C . eq . expected ), 'sorted, expected' , str ( expected ), 'got' , str ( C )) endif C = intersect ( A , B , 'stable' ) expected = [ 7 , 4 ] call unit_test ( 'intersect' , size ( C ). eq . size ( expected ), 'stable size' , 'expected' , size ( expected ), 'got' , size ( c )) if ( size ( C ). eq . size ( expected )) then call unit_test ( 'intersect' , all ( C . eq . expected ), 'stable, expected' , str ( expected ), 'got' , str ( C )) endif strA = [ \"7\" , \"1\" , \"7\" , \"7\" , \"4\" ] strB = [ \"7\" , \"0\" , \"4\" , \"4\" , \"0\" ] strC = intersect ( strA , strB ) strexpected = [ \"4\" , \"7\" ] call unit_test ( 'intersect' , size ( strC ). eq . size ( strexpected ), 'sorted size' ,& 'expected' , size ( strexpected ), 'got' , size ( strc ), 'output=' , str ( strC )) if ( size ( C ). eq . size ( strexpected )) then call unit_test ( 'intersect' , all ( strC . eq . strexpected ), 'sorted, expected' , str ( strexpected ), 'got' , str ( strC )) endif strC = intersect ( strA , strB , 'stable' ) strexpected = [ \"7\" , \"4\" ] call unit_test ( 'intersect' , size ( strC ). eq . size ( strexpected ), 'stable size' ,& 'expected' , size ( strexpected ), 'got' , size ( strc ), 'output=' , str ( strc )) if ( size ( C ). eq . size ( strexpected )) then call unit_test ( 'intersect' , all ( strC . eq . strexpected ), 'stable, expected' , str ( strexpected ), 'got' , str ( strC )) endif fltA = [ 7.777 , 1.111 , 7.777 , 7.777 , 4.444 ] fltB = [ 7.777 , 0.000 , 4.444 , 4.444 , 0.000 ] fltC = intersect ( fltA , fltB ) fltexpected = [ 4.444 , 7.777 ] call unit_test ( 'intersect' , size ( fltC ). eq . size ( fltexpected ), 'sorted size' ,& & 'expected' , size ( fltexpected ), 'got' , size ( fltc )) if ( size ( fltC ). eq . size ( fltexpected )) then call unit_test ( 'intersect' , all ( fltC . eq . fltexpected ), 'sorted, expected' , str ( fltexpected ), 'got' , str ( fltC )) endif fltC = intersect ( fltA , fltB , 'stable' ) fltexpected = [ 7.777 , 4.444 ] call unit_test ( 'intersect' , size ( fltC ). eq . size ( fltexpected ), 'stable size' ,& & 'expected' , size ( fltexpected ), 'got' , size ( fltc )) if ( size ( fltC ). eq . size ( fltexpected )) then call unit_test ( 'intersect' , all ( fltC . eq . fltexpected ), 'stable, expected' , str ( fltexpected ), 'got' , str ( fltC )) endif call unit_test_done ( 'intersect' , msg = 'test completed' ) end subroutine test_intersect !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_setdiff call unit_test_start ( 'setdiff' , 'find the values in A that are not in B' ) ! start tests A = [ 3 , 6 , 2 , 1 , 5 , 1 , 1 ] B = [ 2 , 4 , 6 ] C = setdiff ( A , B ) expected = [ 1 , 3 , 5 ] call unit_test ( 'setdiff' , size ( C ). eq . size ( expected ), 'sorted size' ) if ( size ( C ). eq . size ( expected )) then call unit_test ( 'setdiff' , all ( C . eq . expected ), 'sorted, expected' , str ( expected ), 'got' , str ( C )) endif A = [ 4 , 1 , 3 , 2 , 5 ] B = [ 2 , 1 ] C = setdiff ( A , B , 'sorted' ) expected = [ 3 , 4 , 5 ] call unit_test ( 'setdiff' , size ( C ). eq . size ( expected ), 'stable size' ) if ( size ( C ). eq . size ( expected )) then call unit_test ( 'setdiff' , all ( C . eq . expected ), 'stable, expected' , str ( expected ), 'got' , str ( C )) endif C = setdiff ( A , B , 'stable' ) expected = [ 4 , 3 , 5 ] call unit_test ( 'setdiff' , size ( C ). eq . size ( expected ), 'stable size' ) if ( size ( C ). eq . size ( expected )) then call unit_test ( 'setdiff' , all ( C . eq . expected ), 'stable, expected' , str ( expected ), 'got' , str ( C )) endif strA = [ '3' , '6' , '2' , '1' , '5' , '1' , '1' ] strB = [ '2' , '4' , '6' ] strC = setdiff ( strA , strB ) strexpected = [ '1' , '3' , '5' ] call unit_test ( 'setdiff' , size ( strC ). eq . size ( strexpected ), 'sorted size' ) if ( size ( C ). eq . size ( strexpected )) then call unit_test ( 'setdiff' , all ( strC . eq . strexpected ), 'sorted, expected' , str ( strexpected ), 'got' , str ( strC )) endif strA = [ '4' , '1' , '3' , '2' , '5' ] strB = [ '2' , '1' ] strC = setdiff ( strA , strB , 'sorted' ) strexpected = [ '3' , '4' , '5' ] call unit_test ( 'setdiff' , size ( strC ). eq . size ( strexpected ), 'stable size' ) if ( size ( C ). eq . size ( strexpected )) then call unit_test ( 'setdiff' , all ( strC . eq . strexpected ), 'stable, expected' , str ( strexpected ), 'got' , str ( strC )) endif strC = setdiff ( strA , strB , 'stable' ) strexpected = [ '4' , '3' , '5' ] call unit_test ( 'setdiff' , size ( strC ). eq . size ( strexpected ), 'stable size' ) if ( size ( C ). eq . size ( strexpected )) then call unit_test ( 'setdiff' , all ( strC . eq . strexpected ), 'stable, expected' , str ( strexpected ), 'got' , str ( strC )) endif fltA = [ 3.456 , 6.54321 , 2.01 , 1.008 , 5.35 , 1.008 , 1.008 ] fltB = [ 2.01 , 4.6853 , 6.54321 ] fltC = setdiff ( fltA , fltB ) fltexpected = [ 1.008 , 3.456 , 5.35 ] call unit_test ( 'setdiff' , size ( fltC ). eq . size ( strexpected ), 'sorted size' ) if ( size ( fltC ). eq . size ( strexpected )) then call unit_test ( 'setdiff' , all ( fltC . eq . fltexpected ), 'sorted, expected' , str ( fltexpected ), 'got' , str ( fltC )) endif fltA = [ 4.6853 , 1.008 , 3.456 , 2.01 , 5.35 ] fltB = [ 2.01 , 1.008 ] fltC = setdiff ( fltA , fltB , 'sorted' ) fltexpected = [ 3.456 , 4.6853 , 5.35 ] call unit_test ( 'setdiff' , size ( fltC ). eq . size ( fltexpected ), 'stable size' ) if ( size ( fltC ). eq . size ( fltexpected )) then call unit_test ( 'setdiff' , all ( fltC . eq . fltexpected ), 'stable, expected' , str ( fltexpected ), 'got' , str ( fltC )) endif fltC = setdiff ( fltA , fltB , 'stable' ) fltexpected = [ 4.6853 , 3.456 , 5.35 ] call unit_test ( 'setdiff' , size ( fltC ). eq . size ( fltexpected ), 'stable size' ) if ( size ( fltC ). eq . size ( fltexpected )) then call unit_test ( 'setdiff' , all ( fltC . eq . fltexpected ), 'stable, expected' , str ( fltexpected ), 'got' , str ( fltC )) endif call unit_test_done ( 'setdiff' , msg = 'test completed' ) end subroutine test_setdiff !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_setxor call unit_test_start ( 'setxor' , 'find values two vectors do not share' ) ! start tests A = [ 5 , 1 , 3 , 3 , 3 ] B = [ 4 , 1 , 2 ] C = setxor ( A , B ) expected = [ 2 , 3 , 4 , 5 ] call unit_test ( 'setxor' , size ( C ). eq . size ( expected ), 'sorted size' ) if ( size ( C ). eq . size ( expected )) then call unit_test ( 'setxor' , all ( C . eq . expected ), 'sorted, expected' , str ( expected ), 'got' , str ( C )) endif C = setxor ( A , B , 'stable' ) expected = [ 5 , 3 , 4 , 2 ] call unit_test ( 'setxor' , size ( C ). eq . size ( expected ), 'stable size' ) if ( size ( C ). eq . size ( expected )) then call unit_test ( 'setxor' , all ( C . eq . expected ), 'stable, expected' , str ( expected ), 'got' , str ( C )) endif strA = [ \"5\" , \"1\" , \"3\" , \"3\" , \"3\" ] strB = [ \"4\" , \"1\" , \"2\" ] strC = setxor ( strA , strB ) strexpected = [ \"2\" , \"3\" , \"4\" , \"5\" ] call unit_test ( 'setxor' , size ( strC ). eq . size ( strexpected ), 'sorted size' ) if ( size ( strC ). eq . size ( strexpected )) then call unit_test ( 'setxor' , all ( strC . eq . strexpected ), 'sorted, expected' , str ( strexpected ), 'got' , str ( strC )) endif strC = setxor ( strA , strB , 'stable' ) strexpected = [ \"5\" , \"3\" , \"4\" , \"2\" ] call unit_test ( 'setxor' , size ( strC ). eq . size ( strexpected ), 'sorted size' ) if ( size ( strC ). eq . size ( strexpected )) then call unit_test ( 'setxor' , all ( strC . eq . strexpected ), 'stable, expected' , str ( strexpected ), 'got' , str ( strC )) endif fltA = [ 5.4321 , 1.11111 , 3.55555 , 3.55555 , 3.55555 ] fltB = [ 4.9087 , 1.11111 , 2.0000 ] fltC = setxor ( fltA , fltB ) fltexpected = [ 2.0000 , 3.55555 , 4.9087 , 5.4321 ] call unit_test ( 'setxor' , size ( fltC ). eq . size ( fltexpected ), 'sorted size' ) if ( size ( fltC ). eq . size ( fltexpected )) then call unit_test ( 'setxor' , all ( fltC . eq . fltexpected ), 'sorted, expected' , str ( fltexpected ), 'got' , str ( fltC )) endif fltC = setxor ( fltA , fltB , 'stable' ) fltexpected = [ 5.4321 , 3.55555 , 4.9087 , 2.0000 ] call unit_test ( 'setxor' , size ( fltC ). eq . size ( fltexpected ), 'sorted size' ) if ( size ( fltC ). eq . size ( fltexpected )) then call unit_test ( 'setxor' , all ( fltC . eq . fltexpected ), 'stable, expected' , str ( fltexpected ), 'got' , str ( fltC )) endif call unit_test_done ( 'setxor' , msg = 'test completed' ) end subroutine test_setxor !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_ismember call unit_test_start ( 'ismember' , 'report which values in A are also in B' ) ! start tests ! ! Create two vectors with values in common. A = [ 5 , 3 , 4 , 2 ] B = [ 2 , 4 , 4 , 4 , 6 , 8 ] C = ismember ( A , B ) expected = [ 0 , 0 , 1 , 1 ] call unit_test ( 'ismember' , size ( C ). eq . size ( expected ), 'sorted size' ) if ( size ( C ). eq . size ( expected )) then call unit_test ( 'ismember' , all ( C . eq . expected ), 'sorted, expected' , str ( expected ), 'got' , str ( C )) endif strA = [ \"5\" , \"3\" , \"4\" , \"2\" ] strB = [ \"2\" , \"4\" , \"4\" , \"4\" , \"6\" , \"8\" ] C = ismember ( strA , strB ) expected = [ 0 , 0 , 1 , 1 ] call unit_test ( 'ismember' , size ( C ). eq . size ( expected ), 'sorted size' ) if ( size ( C ). eq . size ( expected )) then call unit_test ( 'ismember' , all ( C . eq . expected ), 'sorted, expected' , str ( expected ), 'got' , str ( C )) endif fltA = [ 5.5421 , 3.5421 , 4.5421 , 2.5421 ] fltB = [ 2.5421 , 4.5421 , 4.5421 , 4.5421 , 6.5421 , 8.5421 ] C = ismember ( fltA , fltB ) expected = [ 0 , 0 , 1 , 1 ] call unit_test ( 'ismember' , size ( C ). eq . size ( expected ), 'sorted size' ) if ( size ( C ). eq . size ( expected )) then call unit_test ( 'ismember' , all ( C . eq . expected ), 'sorted, expected' , str ( expected ), 'got' , str ( C )) endif call unit_test_done ( 'ismember' , msg = 'test completed' ) end subroutine test_ismember !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_isequal use M_sets , only : isequal call unit_test_start ( 'isequal' , 'Find if vector A and B are identical.' ) A = [ 10 , - 10 , 0 , 1 , 2 , 3 , 3 , 2 , 1 , - 10 ] B = [ 10 , - 10 , 0 , 1 , 2 , 3 , - 3 , 2 , 1 , - 10 ] call unit_test ( 'isequal' , isequal ( A , B ). eq . 0 , 'integer A,B expected 0 got' , isequal ( A , B )) call unit_test ( 'isequal' , isequal ( A , A ). eq . 1 , 'integer A,A expected 1 got' , isequal ( A , A )) strA = [ \"0\" , \"0\" , \"1\" , \"2\" , \"3\" , \"3\" , \"2\" , \"1\" ] strB = [ \"0\" , \"O\" , \"1\" , \"2\" , \"3\" , \"3\" , \"2\" , \"1\" ] call unit_test ( 'isequal' , isequal ( strA , strB ). eq . 0 , 'string A,B expected 0 got' , isequal ( strA , strB )) call unit_test ( 'isequal' , isequal ( strA , strA ). eq . 1 , 'string A,A expected 1 got' , isequal ( strA , strA )) fltA = [ 0.5469 , 0.5469 , 1.5469 , 2.5469 , 3.5469 , 3.5469 , 2.5469 , 1.5469 ] fltB = [ 0.5469 , 0.5469 , 1.5469 , 2.5469 , 3.5469 , 3.4569 , 2.5469 , 1.5469 ] call unit_test ( 'isequal' , isequal ( fltA , fltB ). eq . 0 , 'flting A,B expected 0 got' , isequal ( fltA , fltB )) call unit_test ( 'isequal' , isequal ( fltA , fltA ). eq . 1 , 'flting A,A expected 1 got' , isequal ( fltA , fltA )) end subroutine test_isequal !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_issorted use M_sets , only : issorted call unit_test_start ( 'issorted' , 'Find the issorted elements of vector A.' ) A = [ 10 , - 10 , 0 , 1 , 2 , 3 , 3 , 2 , 1 , - 10 ] call unit_test ( 'issorted' , issorted ( A ). eq . 0 , 'sorted, expected 0 got' , issorted ( A )) A = [ - 10 , 10 , 100 , 201 ] call unit_test ( 'issorted' , issorted ( A ). eq . 1 , 'sorted, expected 1 got' , issorted ( A )) strA = [ \"0\" , \"0\" , \"1\" , \"2\" , \"3\" , \"3\" , \"2\" , \"1\" ] call unit_test ( 'issorted' , issorted ( strA ). eq . 0 , 'sorted, expected 0 got' , issorted ( strA )) strA = [ \"10\" , \"20\" , \"30\" ] call unit_test ( 'issorted' , issorted ( strA ). eq . 1 , 'sorted, expected 1 got' , issorted ( strA )) fltA = [ 0.5469 , 0.5469 , 1.5469 , 2.5469 , 3.5469 , 3.5469 , 2.5469 , 1.5469 ] call unit_test ( 'issorted' , issorted ( fltA ). eq . 0 , 'sorted, expected 0 got' , issorted ( fltA )) fltA = [ 1 0.5469 , 2 0.5469 , 3 0.5469 ] call unit_test ( 'issorted' , issorted ( fltA ). eq . 1 , 'sorted, expected 1 got' , issorted ( fltA )) end subroutine test_issorted !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_bool use M_sets , only : bool call unit_test_start ( 'bool' , 'convert logical to integer. 1 is true, 0 is false.' ) call unit_test ( 'bool' , bool ( 10 < 20 ). eq . 1 , 'true expression' , bool ( 10 < 20 )) call unit_test ( 'bool' , bool ( 10 > 20 ). eq . 0 , 'false expression' , bool ( 10 > 20 )) call unit_test ( 'bool' , all ( bool ([ 2 > 1 , 3 == 4 , 10 < 5 , 100 > 50 ]). eq .[ 1 , 0 , 0 , 1 ]), 'elemental' ) A = [ 10 , - 10 , 0 , 1 , 2 , 3 , 3 , 2 , 1 , - 10 ] call unit_test ( 'bool' , all ( bool ( A ). eq .[ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]), 'integers' , str ( bool ( A ))) strA = [ \"0\" , \"0\" , \"1\" , \"2\" , \"3\" , \"3\" , \"2\" , \"1\" ] call unit_test ( 'bool' , all ( bool ( strA ). eq .[ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]), 'strings' , str ( bool ( strA ))) fltA = [ 0.5469 , 0.5469 , 1.5469 , 2.5469 , 3.5469 , 3.5469 , 2.5469 , 1.5469 ] call unit_test ( 'bool' , all ( bool ( fltA ). eq .[ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]), 'real' , str ( bool ( fltA ))) end subroutine test_bool !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT end program runtest","tags":"","url":"sourcefile/test_suite_m_sets.f90.html"},{"title":"demo_unique.f90 – M_sets","text":"Source Code program demo_unique use M_sets , only : unique character ( len =* ), parameter :: g = '(*(g0,1x))' integer , allocatable :: A (:) write ( * , g ) 'UNIQUE' , 'Find the unique elements of vector A.' A = [ 10 , - 10 , 0 , 1 , 2 , 3 , 3 , 2 , 1 , - 10 ] write ( * , g ) 'A=' , A write ( * , g ) unique ( A ) write ( * , g ) unique ( A , setOrder = 'stable' ) end program demo_unique","tags":"","url":"sourcefile/demo_unique.f90.html"},{"title":"demo_setxor.f90 – M_sets","text":"Source Code program demo_setxor use M_sets , only : setxor character ( len =* ), parameter :: g = '(*(g0,1x))' integer , allocatable :: A (:) integer , allocatable :: B (:) write ( * , g ) 'SETXOR' , 'Find values of A and B not in their intersection.' A = [ 5 , 1 , 3 , 3 , 3 ] B = [ 4 , 1 , 2 ] write ( * , g ) 'A=' , A write ( * , g ) 'B=' , B write ( * , g ) setxor ( A , B ) write ( * , g ) setxor ( A , B , 'stable' ) end program demo_setxor","tags":"","url":"sourcefile/demo_setxor.f90.html"},{"title":"demo_setdiff.f90 – M_sets","text":"Source Code program demo_setdiff use M_sets , only : setdiff character ( len =* ), parameter :: g = '(*(g0,1x))' integer , allocatable :: A (:) integer , allocatable :: B (:) write ( * , g ) 'SETDIFF' , 'Find the values in A that are not in B.' A = [ 3 , 6 , 2 , 1 , 5 , 1 , 1 ] B = [ 2 , 4 , 6 ] write ( * , g ) 'A=' , A write ( * , g ) 'B=' , B write ( * , g ) setdiff ( A , B ) write ( * , g ) setdiff ([ 4 , 1 , 3 , 2 , 5 ], [ 2 , 1 ], 'sorted' ) write ( * , g ) setdiff ([ 4 , 1 , 3 , 2 , 5 ], [ 2 , 1 ], 'stable' ) end program demo_setdiff","tags":"","url":"sourcefile/demo_setdiff.f90.html"},{"title":"demo_union.f90 – M_sets","text":"Source Code program demo_union use M_sets , only : union character ( len =* ), parameter :: g = '(*(g0,1x))' integer , allocatable :: A (:) integer , allocatable :: B (:) write ( * , g ) 'UNION' , 'Find the union of vectors A and B.' A = [ 5 , 7 , 1 ] B = [ 3 , 1 , 1 ] write ( * , g ) 'A=' , A write ( * , g ) 'B=' , B write ( * , g ) union ( A , B ) A = [ 5 , 5 , 3 ] B = [ 1 , 2 , 5 ] write ( * , g ) 'A=' , A write ( * , g ) 'B=' , B write ( * , g ) union ( A , B , 'sorted' ) write ( * , g ) union ( A , B , 'stable' ) end program demo_union","tags":"","url":"sourcefile/demo_union.f90.html"},{"title":"demo_intersect.f90 – M_sets","text":"Source Code program demo_intersect use M_sets , only : unique , intersect , union , setdiff , ismember , setxor character ( len =* ), parameter :: g = '(*(g0,1x))' integer , allocatable :: A (:) integer , allocatable :: B (:) write ( * , g ) 'INTERSECT' , 'Find the values common to both A and B.' A = [ 7 , 1 , 7 , 7 , 4 ] B = [ 7 , 0 , 4 , 4 , 0 ] write ( * , g ) 'A=' , A write ( * , g ) 'B=' , B write ( * , g ) intersect ( A , B ) write ( * , g ) intersect ( A , B , setOrder = 'stable' ) end program demo_intersect","tags":"","url":"sourcefile/demo_intersect.f90.html"},{"title":"demo_isequal.f90 – M_sets","text":"Source Code program demo_isequal use M_sets , only : isequal character ( len =* ), parameter :: g = '(*(g0,1x))' integer , allocatable :: A (:) integer , allocatable :: B (:) write ( * , g ) 'isequal' , 'Find if A is equal to B. ' A = [ 10 , - 10 , 0 , 1 , 2 , 3 , 3 , 2 , 1 , - 10 ] B = [ 10 , - 10 , 0 , 1 , 2 , 3 , 3 , 2 , 1 , 10 ] write ( * , g ) 'A=' , A write ( * , g ) 'B=' , B write ( * , g ) isequal ( A , B ) write ( * , g ) 'isequal' , 'Find if A is equal to A. ' write ( * , g ) isequal ( A , A ) end program demo_isequal","tags":"","url":"sourcefile/demo_isequal.f90.html"},{"title":"demo_ismember.f90 – M_sets","text":"Source Code program demo_ismember use M_sets , only : ismember character ( len =* ), parameter :: g = '(*(g0,1x))' integer , allocatable :: A (:) integer , allocatable :: B (:) write ( * , g ) 'ISMEMBER' , 'Determine which elements of A are also in B.' A = [ 5 , 3 , 4 , 2 ] B = [ 2 , 4 , 4 , 4 , 6 , 8 ] write ( * , g ) 'A=' , A write ( * , g ) 'B=' , B write ( * , g ) ismember ( A , B ) end program demo_ismember","tags":"","url":"sourcefile/demo_ismember.f90.html"}]}